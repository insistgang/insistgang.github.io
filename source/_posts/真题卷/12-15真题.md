---
title: 12-15真题
tags:
  - algorithm
  - datastruct
  - 真题
cover: img/realquestion.jpeg
abbrlink: 10a5f53c
date: 2022-09-06 20:13:49
---

## 12-15真题

### 求数列1-1/2+1/3-1/4+...1/n

```cpp
/*
1. 输入n，即为终止数列的数字
2. 循环判定数字，分母为奇数时，系数为正，分母为偶数时，系数为负
3. 最后在循环的过程中执行数字的累加，最后输出结果
*/
#include<iostream>
using namespace std;
int main(){
    int n;
    double total;
    cin>>n;
    for(int i=0;i<n;i++){
        double flag=0;
        if(i%2==0){
            flag=1.0;
        }else{
            flag=-1.0;
        }
        total+=(flag)/(i+1);
    }
    cout<<"total is"<<total<<endl;
    return 0;
}

```

### 输入字符串以！结束，小写转大写，存到text.txt文件中

```cpp
/*
1. 利用while循环输入字符串，以！结束，利用len记录字符长度
2. 循环将小写字符转化成大写字符
3. 将字符串写入文件，然后关闭文件
*/
#include<iostream>
using namespace std;
int main(){
    char str[100];
    FILE *p;
    int i,len=0;
    cout<<"请输入一串英文字符"<<endl;
    while((str[len]=getchar())!='!'){
        len++;
    }
    for(int i=0;i<len;i++)
        if(str[i]>='a'&&str[i]<'z')
            str[i]-=32;
    p=fopen("text.txt","a+");
    fputs(str,p);
    fclose(p);
    return 0;
}

```

### 输入某年某月某日，判断这一天是这一年的第几天

```cpp
/*
1. 输入年月日
2. 判断月份，用switch来判定添加的月份包含的日期
3. 如果月份超过2月，2月按28天来算，再加上当月的天数
4. 最后判定是否为闰年，如果是闰年且月份超过2月再加一天，输出总天数
*/
#include<iostream>
using namespace std;
int main(){
    int year,month,day,sum,leap;
    cin>>year>>month>>day;
    switch(month){
        case 1:sum=0;break;
        case 2:sum=31;break;
		case 3:sum=59;break;
        case 4:sum=90;break;
        case 5:sum=120;break;
        case 6:sum=151;break;
        case 7:sum=181;break;
        case 8:sum=212;break;
        case 9:sum=243;break;
        case 10:sum=273;break;
        case 11:sum=304;break;
        case 12:sum=334;break;
        default:cout<<"data error"<<endl;break;
    }
    sum+=day;
    if(year%400==0||year%4==0&&year%100!=0)
        leap=1;
    else
        leap=0;
    if(leap&&month>2)sum++;
    cout<<sum<<endl;
    return 0;
}

```

### 将文件a和b中的两个字符串交叉合并成为一个字符串，并写入c

列："aaaaa"和"bbb"合并结果为"abababaa"，"bbb"和"aaaaa"合并结果为"bababaaaa"

```cpp
/*
1. 将文件a和文件b的内容分别用两个不同的文件指针fp和fq来打开
2. 将文件c用fr来打开
3. 循环读取fp和fq的字符交叉存放到fr中
4. 最后将fr的内容从头到尾写道fp中，然后将关闭文件程序结束
*/

#include<iostream>
using namespace std;
int main(){
    FILE *fp,*fq,*fc;
    char ch;
    if((fp=fopen("a.txt","r"))==NULL){
        cout<<"can't open file a.txt";
        exit(0);
    }
    if((fp=fopen("b.txt","r"))==NULL){
        cout<<"can't open file b.txt";
        exit(0);
    }
    fr=fopen("c.txt","a+");
    while(!feof(fp))//先输入a文件内容，再输入b文件内容
    {
        ch=fgetc(fp);
        fputc(ch,fr);
        if(!feof(fq)){
            ch=fgetc(fq);
            fputc(ch,fr);
        }
    }
    while(!feof(fq)){
        ch=fgetc(fq);
        fputc(ch,fr);
    }
    fclose(fp);
    fclose(fq);
    fclose(fr);
    return 0;
}
```

### 实现student类对学号姓名三门课的成绩进行管理

1. 单独设置获取三门课的成绩
2. 可以计算平均成绩

```cpp
/*
1. 写input函数，输入学生的信息，循环读取三个学生的姓名成绩
2. 写avg函数，根据每名学生的三门课的成绩信息，来计算这位学生的平均成绩
*/
#include<iostream>
using namespace std;
struct student{
    char num[6];
    char name[20];
    float score[3];
    float aver;
}stu[3];
void input(student stu[]){
    int i;
    cout<<"please enter the information of student"<<endl;
    for(i=0;i<3;i++)
        scanf("%s%s%f%f%f",&stu[i].num,&stu[i].name,&stu[i].score[0],&stu[i].score[1],&stu[i].score[2]);
}
void avg(struct student stu[]){
    int i,j;
    float sum,aver;
    for(j=0;j<3;j++){
        sum=0;
        for(i=0;i<3;i++)
            sum+=(stu[j].score[i]);
       	aver=sum/3.0;
        stu[i].aver=aver;
    }
}
int main(){
    int i;
    input(student stu[]);
    avg(student stu[]);
   for(i=0;i<3;i++) printf("%s%s%f%f%f%f",stu[i].num,stu[i].name,stu[i].score[0],stu[i].score[1],stu[i].score[2],stu[i].aver);
    return 0;
}
```

### 输入n组等长字符串，用指针的方法进行冒泡排序，在函数中实现

```cpp
/*
1. 写冒泡排序，用字符串比较来交换的方法来进行排序
2. 利用指针数组p来存放输入的数组
3. p和字符的组数n传参排序，最后输出
*/
#include<iostream>
#include<cstring>
using namespace std;
void sort(char *str[],int size){
    int i,j;
    char *temp;
    for(i=0;i<size-1;i++){
        for(j=0;j<size-i-1;j++){
            if(strcmp(str[j],str[j+1])>0){
                temp=str[j];
                str[j]=str[j+1];
                str[j+1]=temp;
            }
        }
    }
int main(){
    char *p[200],str[200][20];
    int i,n;
    cout<<"请输入字符串的个数：";
    cin>>n;
    for(int i=0;i<n;i++){
        cin>>str[i];
        p[i]=str[i];
    }
    sort(p,n);
    cout<<"排序后的结果:";
    for(int i=0;i<n;i++){
        cout<<p[i]<<endl;
    }
    return 0;
}

```

### 输入一组字符倒序输出，输出结果保存到out.txt

```cpp
#include<stdio.h>
void string(char *str,FILE *fp){
    if(*str=='\0') return;
    else{
        string(str+1,fp);
        fputc(*str,fp);
    }
}
int main(){
    FILE *fp;
    char *ch;
    char str[100];
    if(fp=fopen("out.txt","w+")==NULL){
        cout<<"cannot open file"<<endl;
        exit(1);
    }
    cout<<"input a string:\n";
    scanf("%s",str);
    ch=str;
    string(ch,fp);
    fclose(fp);
}
```

### 黑色星期五，每个月中十三号是星期五称为黑色星期五

```cpp
/*
1900年1月1日星期一
总天数=该年之前的年份总天数+该年1月1日到该月1日为止的天数+该月1日到该日的天数
1. 完成三个函数，第一个返回平年每月的天数，第二个返回闰年每月的天数，第三个判断闰年还是平年
2. 从1900年1月1日开始往后加，求总天数，先加到前一年通过是否是闰年判断总天数
3. 根据返回的月份来累加天数，在根据日加到最后的天数13即为总天数
4. 总天数取余数结果为5即为黑色星期五
*/
#include<iostream>
using namespace std;
int run(int year){
    if(year%400==0||year%100!=0&&year%4==0)
        return 1;
    return 0;
}
int main(){
    int n;
    cin>>n;
    int arr[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};
    int sum=0;
    for(int i=1900;i<n;i++){
        if(run(i)==1)
            sum+=366;
        else
            sum+=365;
    }
    if(run(n)==1){
        arr[2]=29;
    }
    for(int i=1;i<=12;i++){
        if(run(n)==1){
            sum=13+sum;
            if(sum%7==5){
                cout<<n<<"年"<<i<<"月"<<"13号"<<endl;
            }
            sum=sum-13+arr[i];
        }
    }
    return 0;
}
```

### 二叉树以二叉链表存储，证明二叉树是满二叉树

```cpp
//一个n层满二叉树总数为2的n次幂-1，利用先序遍历递归
#include<stdio.h>
#include<math.h>
int i=0;
int sumtree(Bitree *T){
    if(T){
        i++;
        sumtree(T->lchild);
        sumtree(T->rchild);
    }
}
//二叉树深度
int height(BiTree T){
    if(T==NULL) return 0;
    int u=height(T->lchild);//统计左子树高度
    int v=height(T->rchild);//统计右子树高度
    if(u>v) return u+1;
    return v+1;
}
int main(){
    BiTree *T;
    sumtree(T);
    int h=height(T);
    if(i==(pow(2,h)-1))
        printf("此二叉树为满二叉树");
    else
        printf("此二叉树不是满二叉树");
}
```

### 二叉排序树以x为根节点的子树。要求用非递归算法并释放掉该结点。(删除某个结点)

```cpp
bool delete(BiTree *p){
    BiTree *q,*s;
    if(p->rchild==NULL)//右子树空则只需重接它的左子树
    {
        p=p->lchild;
    }else if(p->lchild==NULL)//只需要重接它的右子树
    {
        p=p->rchild;
    }else{//左右子树均不空
        q=p;
        s=p->lchild;
        while(s->rchild){//转左，然后向右走到尽头
            q=s;
            s=s->rchild;
        }
        p->data=s->data;//s指向被删节点的直接前驱
        if(q!=p)//s有右子树
            q->rchild=s->lchild;//重新连接q的右子树
        else
            q->lchild=s->lchild;//重新连接q的左子树
        free(s);
    }
    return true;
}

```

### ABCDEF六个变量分别是1-6的整数，且各不相同，组成一个等边三角形，找出三边相等有多少种可能性。即A+B+D=A+C+F=D+E+F

```cpp
#include<iostream>
using namespace std;
int main(){
    int a,b,c,d,e,f;
    int cnt=0;
    for(a=6;a>=1;a--){
        for(b=6;b>=1;b--){
            if(b!=a){
                for(c=6;c>=1;c--){
                    if(b!=c&&a!=c){
                        for(d=6;d>=1;d--){
                            if(d!=c&&d!=b&&d!=a){
                                for(e=6;e>=1;e--){
                                    if(e!=a&&e!=b&&e!=c&&e!=d){
                                        for(f=6;f>=1;f--){
                                            if(f!=a&&f!=b&&f!=c&&f!=e){
                                                if(a+b+d==a+c+f=d+e+f)
                                                    cnt++;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    cout<<cnt<<endl;
    return 0;
}
```

