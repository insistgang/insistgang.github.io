---
title: 22真题
abbrlink: a37401f9
date: 2022-09-06 20:14:25
tags:
  - algorithm
  - datastruct
  - 真题
cover: img/realquestion.jpeg
---

## 22真题

### 5. （1）使用C语言给出双链表的数据结构(2)写出删除结点的C语言实现

```cpp
struct node{
    struct node *prev;
    int data;
    struct node *next;
}
void deletion_beginning(node *head){
    struct node *ptr;
    if(head==NULL)
    {
        printf("UNDERFLOW\n");
    }else if(head->next==NULL){
        head=NULL;
        free(head);
        printf("not delete");
    }
    else{
        ptr=head;
        head=head->next;
        head->prev=NULL;
        free(ptr);
        printf("not delete");
    }
}
void deletion_last(note *head){
    node *ptr;
    if(head==NULL){
        printf("UNDERFLOW\n");
    }
    else
    {
        head=NULL:
        free(head);
        printf("not delete");
    }
}
void deletion_specified(node *head){
    node *ptr,*temp;
    int val;
    printf("Enter the data after which the node is to be delete:");
    scanf("%d",&val);
    ptr=head;
    while(ptr->data!=val)
        ptr=ptr->next;
    if(ptr==NULL){
        printf("Can't delete\n");
    }
    else{
        ptr->next->prev=ptr->prev;
        ptr->prev=ptr->next;
        free(ptr);
        printf("not delete");
    }
}
```

### 6. 对于输入的非负十进制整数，打印输出与其等值的八进制数

1. 用C语言给出栈的存储结构
2. 基于上述存储结构，给出元素入栈和出栈的C语言实现
3. 基于前两问，用C语言实现本题目

```cpp
#define MaxSize 50
typedef struct{
    Elemtype data[MaxSize];
    int top;
}SqStack;
bool Push(SqStack &S,Elemtype x){
    if(S.top==MaxSize-1)
        return false;
    S.data[++S.top]=x;
    return true;
}

bool Pop(SqStack &S,Elemtype &x){
    if(S.top==-1)
        return false;
    x=S.data[S.top--];
    return true;
}

SqStack s;
int N;
ElemType e;
if(InitStack(S))printf("\n 初始化栈成功！\n");
printf("\n请输入想要转换的非负十进制整数(以回车键结束):\n");
scanf("%d",&N);
while(N){
    Push(S,N%8);
    N/=8;
}
printf("\n 该数对应的八进制数为：\n");
while(!StackEmpty(S)){
    Pop(S,&e);
    printf("%d",e);
}
```

### B-树结点数据结构的C语言定义和查找操作的实现

```cpp
struct BTreeNode{
    int *keys;//存储关键字的数组
    int t;//最小度
    BTreeNode **C;
    int n;//记录当前结点包含的关键字个数
    bool leaf;//叶子结点的一个标记，如果是叶子结点则为true，否则false
}

*BTreeNode search(BTreeNode *this,int k){
    //找到第一个大于等于待查找关键字k的关键字
    int i=0;
    while(i<this.n&&k>this.keys[i])
        i++;
    //如果找到的第一个关键字等于k，返回结点指针
    if(this.keys[i]==k)
        return this;
    //如果没找到关键字k且当前结点为叶子结点则返回NULL
    if(leaf==true)
        return NULL;
    //递归访问恰当的子代
    return search(this.C[i],k);
}
```

