<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Leo的笔记本</title>
  
  
  <link href="https://insistgang.github.io/atom.xml" rel="self"/>
  
  <link href="https://insistgang.github.io/"/>
  <updated>2022-08-07T05:25:13.000Z</updated>
  <id>https://insistgang.github.io/</id>
  
  <author>
    <name>insistgang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>专业课第二次作业</title>
    <link href="https://insistgang.github.io/posts/97f32b1f.html"/>
    <id>https://insistgang.github.io/posts/97f32b1f.html</id>
    <published>2026-01-04T15:12:48.856Z</published>
    <updated>2022-08-07T05:25:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第二次作业"><a href="#第二次作业" class="headerlink" title="第二次作业"></a>第二次作业</h1><p>1.求n的阶乘<br>n的阶乘=n * n-1 * n-2 * n -3…* 2 *  1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,s=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        s*=i;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>14.从键盘输入10个整数，统计其中正数、负数和零的个数，并在屏幕上输出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> z,f,l;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            z++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[i]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            f++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;z&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;f&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;l&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>求1~1000之间能被13整除的最大的数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i*<span class="number">13</span>&gt;<span class="number">1000</span>)&#123;</span><br><span class="line">            t=i<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“水仙花数”是指一一个三位数,其各位数的立方之和正好等于该数本身,例如，153=1^3+5^3+3^3 ,请输出所有的水仙花数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">100</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">        a=i/<span class="number">100</span>;<span class="comment">//百位</span></span><br><span class="line">        b=i/<span class="number">10</span>%<span class="number">10</span>;<span class="comment">//十位</span></span><br><span class="line">        c=i%<span class="number">10</span>;<span class="comment">//个位</span></span><br><span class="line">        <span class="keyword">if</span>(i==a*a*a+b*b*b+c*c*c)&#123;</span><br><span class="line">            cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从键盘输入整数n，输出1+3+5+7+…+n,前n项的和。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,s=<span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i+=<span class="number">2</span>)&#123;</span><br><span class="line">        s+=i;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;s;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编写程序，求满足下列条件的最大的n:<br>1^2+2^2+3^2+…..+n^2&lt; 1000</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s=<span class="number">0</span>,t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s&lt;<span class="number">1000</span>)&#123;</span><br><span class="line">            s+=i*i;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            t=i<span class="number">-2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s=<span class="number">0</span>,t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">        s+=i*i;</span><br><span class="line">        <span class="keyword">if</span>(s&gt;<span class="number">1000</span>)&#123;</span><br><span class="line">            t=i<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入一批非0的数，直到输入0为止，计算其中奇数的平均值和偶数的乘积</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[N];</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,t=<span class="number">0</span>,num,pj=<span class="number">0</span>,ji=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;a[i]&amp;&amp;a[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    num=i<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=num)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[j]%<span class="number">2</span>)&#123;</span><br><span class="line">            pj+=a[j];</span><br><span class="line">            t++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ji*=a[j];</span><br><span class="line">        &#125;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;pj*(<span class="number">1.0</span>)/t*(<span class="number">1.0</span>)&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ji&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第二次作业&quot;&gt;&lt;a href=&quot;#第二次作业&quot; class=&quot;headerlink&quot; title=&quot;第二次作业&quot;&gt;&lt;/a&gt;第二次作业&lt;/h1&gt;&lt;p&gt;1.求n的阶乘&lt;br&gt;n的阶乘=n * n-1 * n-2 * n -3…* 2 *  1&lt;/p&gt;
&lt;figure </summary>
      
    
    
    
    
    <category term="考研" scheme="https://insistgang.github.io/tags/%E8%80%83%E7%A0%94/"/>
    
    <category term="C语言" scheme="https://insistgang.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>专业课细节</title>
    <link href="https://insistgang.github.io/posts/d8993ced.html"/>
    <id>https://insistgang.github.io/posts/d8993ced.html</id>
    <published>2023-11-27T14:29:50.000Z</published>
    <updated>2024-12-16T05:46:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="专业课细节题"><a href="#专业课细节题" class="headerlink" title="专业课细节题"></a>专业课细节题</h1><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h3 id="指针对应数组位置，地址计算"><a href="#指针对应数组位置，地址计算" class="headerlink" title="指针对应数组位置，地址计算"></a>指针对应数组位置，地址计算</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p=a[<span class="number">0</span>];</span><br><span class="line">p+=<span class="number">6</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*(*(a+<span class="number">2</span>)+<span class="number">3</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*(a[<span class="number">1</span>]+<span class="number">3</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*(&amp;a[<span class="number">0</span>][<span class="number">0</span>]+<span class="number">8</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">19</span></span><br></pre></td></tr></table></figure><h3 id="指针数组比较"><a href="#指针数组比较" class="headerlink" title="指针数组比较"></a>指针数组比较</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *language[<span class="number">10</span>]=&#123;<span class="string">&quot;FORTRAN&quot;</span>,<span class="string">&quot;BASIC&quot;</span>,<span class="string">&quot;PASCAL&quot;</span>,<span class="string">&quot;JAVA&quot;</span>,<span class="string">&quot;C&quot;</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,language[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,language[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,*language[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,*language[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BASIC</span><br><span class="line">PASCAL</span><br><span class="line">B</span><br><span class="line">P</span><br></pre></td></tr></table></figure><h3 id="字符串输入输出"><a href="#字符串输入输出" class="headerlink" title="字符串输入输出"></a>字符串输入输出</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> a1[<span class="number">6</span>],a2[<span class="number">6</span>],a3[<span class="number">6</span>],a4[<span class="number">6</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>,a1,a2);</span><br><span class="line">gets(a3);</span><br><span class="line">gets(a4);</span><br><span class="line"><span class="built_in">puts</span>(a1);</span><br><span class="line"><span class="built_in">puts</span>(a2);</span><br><span class="line"><span class="built_in">puts</span>(a3);</span><br><span class="line"><span class="built_in">puts</span>(a4);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">aa bb</span><br><span class="line">cc dd</span><br><span class="line">aa</span><br><span class="line">bb</span><br><span class="line"></span><br><span class="line">cc dd</span><br></pre></td></tr></table></figure><h3 id="求精确值"><a href="#求精确值" class="headerlink" title="求精确值"></a>求精确值</h3><p> π /2=1+1/3+1/3 * 2/5+1/3 * 2/5 * 3/7 + 1/3 * 2/5 * 3/7 +1/3 * 2/5 * 3/7 *4/9 +</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">double</span> s=<span class="number">1.0</span>,eps,t=<span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;eps);</span><br><span class="line"><span class="keyword">for</span>(n=<span class="number">1</span>;n&lt;eps;n++)&#123;</span><br><span class="line">t=t*n/(<span class="number">2</span>*n+<span class="number">1</span>);</span><br><span class="line">s+=t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lf&quot;</span>,s);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10以内的约数"><a href="#10以内的约数" class="headerlink" title="10以内的约数"></a>10以内的约数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>],n;</span><br><span class="line"><span class="keyword">int</span> i,j=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line"><span class="keyword">if</span>(n%i==<span class="number">0</span>)</span><br><span class="line">a[j++]=i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;j;i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; %6d&quot;</span>,a[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是</p><p>1 2 5</p><p>数组反转</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">//int x[100],n;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ive</span><span class="params">(<span class="keyword">int</span> x[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t,*p;</span><br><span class="line">p=x+n<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(x&lt;p)&#123;</span><br><span class="line">t=*x;</span><br><span class="line">*x++=*p;</span><br><span class="line">*p--=t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>&#125;;</span><br><span class="line">ive(a,<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0987654321</span></span><br><span class="line">对于*x++相当于*(x++)若对应x[<span class="number">0</span>] *p--相当于*(p--)</span><br><span class="line">    先保存x[<span class="number">0</span>]将最后一个p[n<span class="number">-1</span>]赋值给x[<span class="number">0</span>]，再将p[n<span class="number">-1</span>]赋值初始的x[<span class="number">0</span>]</span><br><span class="line">    总体而言即交换第一个最后一个，第二个倒数第二个，第三个倒数第三个……以此类推，完成倒序数组</span><br></pre></td></tr></table></figure><p>改变字符串位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span> *w,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> t,*s1,*s2;</span><br><span class="line">s1=w;</span><br><span class="line">s2=w+n<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(s1&lt;s2)&#123;</span><br><span class="line">t=*s1++;</span><br><span class="line">*s1=*s2--;</span><br><span class="line">*s2=t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> p[]=<span class="string">&quot;1234567&quot;</span>;</span><br><span class="line">fun(p,<span class="built_in">strlen</span>(p));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,p);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1711717</span></span><br><span class="line">第一个不变，t=s1[<span class="number">0</span>]=<span class="number">1</span>,s1[<span class="number">1</span>]=s2[<span class="number">6</span>]=<span class="number">7</span>,s2[<span class="number">5</span>]=t=<span class="number">1</span>，第二个和倒数第二个改变 w=<span class="string">&quot;1734517&quot;</span></span><br><span class="line">第二个不变，t=s1[<span class="number">1</span>]=<span class="number">7</span>,s1[<span class="number">2</span>]=s2[<span class="number">5</span>]=<span class="number">1</span>,s2[<span class="number">4</span>]=t=<span class="number">7</span>,第三个和倒数第三个改变w=<span class="string">&quot;1714717&quot;</span></span><br><span class="line">第三个不变，t=s[<span class="number">2</span>]=<span class="number">1</span>,s1[<span class="number">3</span>]=s2[<span class="number">4</span>]=<span class="number">7</span>,s2[<span class="number">3</span>]=t=<span class="number">1</span>;第四个和倒数第四个即中间一个变w=<span class="string">&quot;1711717&quot;</span></span><br></pre></td></tr></table></figure><p>上一题的细节，字符串数组和字符数组长度和大小的问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> p[]=<span class="string">&quot;1234567&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">8</span>]=&#123;<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;v&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;u&#x27;</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>,<span class="built_in">strlen</span>(p),<span class="built_in">strlen</span>(a),<span class="keyword">sizeof</span>(p),<span class="keyword">sizeof</span>(a));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span> <span class="number">8</span> <span class="number">8</span> <span class="number">8</span></span><br><span class="line">第一个字符串数组p的数字只有<span class="number">7</span>个，所以长度是<span class="number">7</span>，但是大小要算上最后的一个<span class="string">&#x27;\0&#x27;</span>，所以为<span class="number">8</span></span><br><span class="line">第二个字符数组a的字符个数有八个，所以长度为<span class="number">8</span>，大小也为<span class="number">8</span></span><br></pre></td></tr></table></figure><p>结构体指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">str1</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> c[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">char</span> *s;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">str1</span> <span class="title">s1</span>[2]&#123;</span>&#123;<span class="string">&quot;ABCD&quot;</span>,<span class="string">&quot;EFGH&quot;</span>&#125;,&#123;<span class="string">&quot;IJK&quot;</span>,<span class="string">&quot;LMN&quot;</span>&#125;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">str2</span>&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">str1</span> <span class="title">sr</span>;</span></span><br><span class="line"><span class="keyword">int</span> d;</span><br><span class="line">&#125;s2=&#123;<span class="string">&quot;OPQ&quot;</span>,<span class="string">&quot;RST&quot;</span>,<span class="number">32767</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">str1</span> *<span class="title">p</span>[2];</span></span><br><span class="line">p[<span class="number">0</span>]=&amp;s1[<span class="number">0</span>];</span><br><span class="line">p[<span class="number">1</span>]=&amp;s1[<span class="number">1</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,++p[<span class="number">1</span>]-&gt;s);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,s2.sr.c[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MN</span><br><span class="line">Q</span><br><span class="line">对于字符串s输出，若在前面写出++s，若当前下标为<span class="number">0</span>则从下标<span class="number">1</span>处输出整个字符串。</span><br><span class="line">指针数组指针p[<span class="number">0</span>]指向s1[<span class="number">0</span>]所在地址,p[<span class="number">1</span>]指向s1[<span class="number">1</span>]所在地址</span><br><span class="line">对于字符串指针数组可以用++p[<span class="number">1</span>]-&gt;s来输出，但对于字符串数组只能直接调用，p[<span class="number">1</span>]-&gt;c不能在前面和后面进行++</span><br></pre></td></tr></table></figure><p>三维指针数组找变量值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *pp[<span class="number">2</span>][<span class="number">3</span>]=&#123;<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;defgh&quot;</span>,<span class="string">&quot;ijkl&quot;</span>,<span class="string">&quot;mnopqr&quot;</span>,<span class="string">&quot;stuvw&quot;</span>,<span class="string">&quot;xyz&quot;</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,***(pp+<span class="number">1</span>));<span class="comment">//m</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,**pp[<span class="number">0</span>]);<span class="comment">//a</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,(*(*(pp+<span class="number">1</span>)+<span class="number">1</span>))[<span class="number">4</span>]);<span class="comment">//w</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,*(pp[<span class="number">1</span>][<span class="number">2</span>]+<span class="number">2</span>));<span class="comment">//z</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,**(pp+<span class="number">1</span>));<span class="comment">//defgh</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">m</span><br><span class="line">a</span><br><span class="line">w</span><br><span class="line">z</span><br><span class="line">mnopqr</span><br><span class="line">三维数组比较抽象，默认去掉一个*就可以清晰很多了。</span><br></pre></td></tr></table></figure><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> *s)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> f1,f2;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">2</span>)</span><br><span class="line">*s=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">fun(n<span class="number">-1</span>,&amp;f1);</span><br><span class="line">fun(n<span class="number">-2</span>,&amp;f2);</span><br><span class="line">*s=f1+f2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">fun(<span class="number">6</span>,&amp;x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,x);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">迭代 f(1)=f(2)=1 f(3)=f(1)+f(2)=2 f(4)=f(3)+f(2)=2+1=3 f(5)=f(4)+f(3)=3+2=5 f(6)=f(5)+f(4)=5+3=8</span><br></pre></td></tr></table></figure><h3 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">E</span>&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line">&#125;in;</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line">&#125;e;</span><br><span class="line">e.a=<span class="number">1</span>;e.b=<span class="number">2</span>;</span><br><span class="line">e.in.x=e.a*e.b;</span><br><span class="line">e.in.y=e.a+e.b;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n%d&quot;</span>,e.in.x,e.in.y);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">8</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;专业课细节题&quot;&gt;&lt;a href=&quot;#专业课细节题&quot; class=&quot;headerlink&quot; title=&quot;专业课细节题&quot;&gt;&lt;/a&gt;专业课细节题&lt;/h1&gt;&lt;h2 id=&quot;指针&quot;&gt;&lt;a href=&quot;#指针&quot; class=&quot;headerlink&quot; title=&quot;指针&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="C语言" scheme="https://insistgang.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>专业课代码复盘</title>
    <link href="https://insistgang.github.io/posts/78c7d46b.html"/>
    <id>https://insistgang.github.io/posts/78c7d46b.html</id>
    <published>2023-11-27T14:29:30.000Z</published>
    <updated>2024-12-16T04:45:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="C代码复盘"><a href="#C代码复盘" class="headerlink" title="C代码复盘"></a>C代码复盘</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="1-1000以内的完数"><a href="#1-1000以内的完数" class="headerlink" title="1. 1000以内的完数"></a>1. 1000以内的完数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">1000</span>;i++)&#123;</span><br><span class="line">s=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i%j==<span class="number">0</span>)</span><br><span class="line">s+=j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(s==i)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d is from&quot;</span>,i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line"><span class="keyword">if</span>(i%j==<span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,j);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-100-200中所有的素数"><a href="#2-100-200中所有的素数" class="headerlink" title="2. 100~200中所有的素数"></a>2. 100~200中所有的素数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> leap=<span class="number">1</span>,t=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">101</span>;i&lt;=<span class="number">200</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j*j&lt;=i;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i%j==<span class="number">0</span>)&#123;</span><br><span class="line">leap=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(leap==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i);</span><br><span class="line">t++;</span><br><span class="line">&#125;</span><br><span class="line">leap=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-转置"><a href="#3-转置" class="headerlink" title="3. 转置"></a>3. 转置</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line"><span class="keyword">int</span> t=a[i][j];</span><br><span class="line">a[i][j]=a[j][i];</span><br><span class="line">a[j][i]=t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-给定一个数组，判断有多少种不同的数字"><a href="#4-给定一个数组，判断有多少种不同的数字" class="headerlink" title="4. 给定一个数组，判断有多少种不同的数字"></a>4. 给定一个数组，判断有多少种不同的数字</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10010</span></span><br><span class="line"><span class="keyword">int</span> s[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">11</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">23</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(s[a[i]]==<span class="number">0</span>)&#123;</span><br><span class="line">s[a[i]]=<span class="number">1</span>;</span><br><span class="line">t++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;一共有%d个不同的数字&quot;</span>,t);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-将一个整数存放到一个数组中。存放时按逆序存放。例如：483-存放-成”384”。"><a href="#5-将一个整数存放到一个数组中。存放时按逆序存放。例如：483-存放-成”384”。" class="headerlink" title="5. 将一个整数存放到一个数组中。存放时按逆序存放。例如：483 存放 成”384”。"></a>5. 将一个整数存放到一个数组中。存放时按逆序存放。例如：483 存放 成”384”。</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span> *a,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">if</span>((i=n/<span class="number">10</span>)!=<span class="number">0</span>)</span><br><span class="line">fun(a+<span class="number">1</span>,i);</span><br><span class="line">*a=n%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">100</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">fun(str,a);</span><br><span class="line"><span class="built_in">puts</span>(str);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一年的第几天"><a href="#一年的第几天" class="headerlink" title="一年的第几天"></a>一年的第几天</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> months[<span class="number">13</span>]=&#123;<span class="number">0</span>,<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> year,month,day;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;year,&amp;month,&amp;day);</span><br><span class="line"><span class="keyword">if</span>(year%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;year%<span class="number">100</span>!=<span class="number">0</span>||year%<span class="number">400</span>==<span class="number">0</span>)&#123;</span><br><span class="line">months[<span class="number">2</span>]=<span class="number">29</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;month;i++)&#123;</span><br><span class="line">s+=months[i];</span><br><span class="line">&#125;</span><br><span class="line">s+=day;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;这一年是当年的第%d天&quot;</span>,s);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8进制转10进制"><a href="#8进制转10进制" class="headerlink" title="8进制转10进制"></a>8进制转10进制</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span> s[<span class="number">100</span>])</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>,n=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(s[i]!=<span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">n=n*<span class="number">8</span>+s[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="斐波那契数列前40项"><a href="#斐波那契数列前40项" class="headerlink" title="斐波那契数列前40项"></a>斐波那契数列前40项</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f1=<span class="number">1</span>,f2=<span class="number">1</span>,f3;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d &quot;</span>,f1,f2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">38</span>;i++)&#123;</span><br><span class="line">f3=f1+f2;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,f3);</span><br><span class="line">f1=f2;</span><br><span class="line">f2=f3;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最大公约数和最小公倍数"><a href="#最大公约数和最小公倍数" class="headerlink" title="最大公约数和最小公倍数"></a>最大公约数和最小公倍数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_ele</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="comment">//最大公约数</span></span><br><span class="line">    <span class="keyword">int</span> result=<span class="number">1</span>,minn;</span><br><span class="line">    minn=a&lt;b?a:b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=minn;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a%i==<span class="number">0</span>&amp;&amp;b%i==<span class="number">0</span>)&#123;</span><br><span class="line">            result=i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min_time</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="comment">//最大公约数</span></span><br><span class="line">    <span class="keyword">int</span> result,maxn;</span><br><span class="line">    maxn=a&gt;b?a:b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=maxn;i&lt;=a*b;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i%a==<span class="number">0</span>&amp;&amp;i%b==<span class="number">0</span>)&#123;</span><br><span class="line">            result=i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n%d&quot;</span>,max_ele(a,b),min_time(a,b));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="鞍点"><a href="#鞍点" class="headerlink" title="鞍点"></a>鞍点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>][<span class="number">5</span>],rmax[<span class="number">5</span>],cmin[<span class="number">5</span>],rx[<span class="number">5</span>],ry[<span class="number">5</span>],cx[<span class="number">5</span>],cy[<span class="number">5</span>],t=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        rmax[i]=a[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(rmax[i]&lt;a[i][j])&#123;</span><br><span class="line">                rmax[i]=a[i][j];</span><br><span class="line">                rx[i]=i;</span><br><span class="line">                ry[i]=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)&#123;</span><br><span class="line">        cmin[j]=<span class="number">100000</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cmin[j]&gt;a[i][j])&#123;</span><br><span class="line">                cmin[j]=a[i][j];</span><br><span class="line">                cx[j]=i;</span><br><span class="line">                cy[j]=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(rx[i]==cx[j]&amp;&amp;ry[i]==cy[j])&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>,rx[i]+<span class="number">1</span>,ry[i]+<span class="number">1</span>,a[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">方法二</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n;<span class="comment">//m行n列的矩阵 </span></span><br><span class="line">    <span class="keyword">int</span> Array[<span class="number">10</span>][<span class="number">10</span>];<span class="comment">//定义一个矩阵 </span></span><br><span class="line">    <span class="keyword">int</span> i,j,b=<span class="number">0</span>,c=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;m,&amp;n);<span class="comment">//输入行和列数 </span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)<span class="comment">//输入矩阵 </span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;Array[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max=<span class="number">0</span>;<span class="comment">//用于比较每行最大的值 </span></span><br><span class="line">    <span class="keyword">int</span> min=<span class="number">0</span>;<span class="comment">//用于比较每行中最小的值 </span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        max=Array[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)<span class="comment">//找出第i行最大值</span></span><br><span class="line">        &#123;</span><br><span class="line">             </span><br><span class="line">             <span class="keyword">if</span>(Array[i][j]&gt;max)</span><br><span class="line">             &#123;</span><br><span class="line">                 max=Array[i][j];</span><br><span class="line">                 b=j;<span class="comment">//将最大值的列数赋值给b </span></span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        min=Array[<span class="number">0</span>][b];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;m;k++)<span class="comment">//找出每行最小值 </span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(Array[k][b]&lt;min)</span><br><span class="line">            &#123;</span><br><span class="line">                min=Array[k][b];</span><br><span class="line">                c=k;<span class="comment">//将最小的行数赋值给c </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(min==max)<span class="comment">//判断该点是否为鞍点 </span></span><br><span class="line">    &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Array[%d][%d]=%d&quot;</span>,c,b,Array[c][b]);</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//if ture，输出鞍点 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(min!=max)<span class="comment">//根据题目要求，没有鞍点输出None </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;None&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="杨辉三角形"><a href="#杨辉三角形" class="headerlink" title="杨辉三角形"></a>杨辉三角形</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>][<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">a[i][<span class="number">0</span>]=a[i][i]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">a[i][j]=a[i<span class="number">-1</span>][j]+a[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i;j++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除数组中值为n的元素"><a href="#删除数组中值为n的元素" class="headerlink" title="删除数组中值为n的元素"></a>删除数组中值为n的元素</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del_element</span><span class="params">(<span class="keyword">int</span> num[],<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> i,n;</span><br><span class="line">m=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;please input n\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">del_element(num,n);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,num[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del_element</span><span class="params">(<span class="keyword">int</span> num[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line"><span class="keyword">if</span>(num[i]==n)&#123;</span><br><span class="line"><span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;m;j++)</span><br><span class="line">num[j<span class="number">-1</span>]=num[j];</span><br><span class="line">m--;</span><br><span class="line">i--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h3 id="利用指针法，输出二维数组各元素"><a href="#利用指针法，输出二维数组各元素" class="headerlink" title="利用指针法，输出二维数组各元素"></a>利用指针法，输出二维数组各元素</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 4</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[N][M];</span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line">p=a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,p++);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">p=*a;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*p++);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="计算字符串子串出现次数"><a href="#计算字符串子串出现次数" class="headerlink" title="计算字符串子串出现次数"></a>计算字符串子串出现次数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">100</span>],b[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> len1,len2,t=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>,a,b);</span><br><span class="line">    len1=<span class="built_in">strlen</span>(a);</span><br><span class="line">    len2=<span class="built_in">strlen</span>(b);</span><br><span class="line">    <span class="keyword">int</span> i,j,k;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=len1-len2;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>,k=i;j&lt;len2&amp;&amp;b[j]==a[k];j++,k++);</span><br><span class="line">        <span class="keyword">if</span>(j==len2)</span><br><span class="line">            t++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;t;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="达芬奇密码解密"><a href="#达芬奇密码解密" class="headerlink" title="达芬奇密码解密"></a>达芬奇密码解密</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">100</span>],a[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;密文：&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line"><span class="keyword">int</span> len=<span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(s[i]&gt;=<span class="string">&#x27;A&#x27;</span>&amp;&amp;s[i]&lt;=<span class="string">&#x27;Z&#x27;</span>)&#123;</span><br><span class="line">a[i]=<span class="string">&#x27;A&#x27;</span>+<span class="string">&#x27;Z&#x27;</span>-s[i];</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i]&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;s[i]&lt;=<span class="string">&#x27;z&#x27;</span>)&#123;</span><br><span class="line">a[i]=<span class="string">&#x27;a&#x27;</span>+<span class="string">&#x27;z&#x27;</span>-s[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;原文：&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,a);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断是否为回文串"><a href="#判断是否为回文串" class="headerlink" title="判断是否为回文串"></a>判断是否为回文串</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line"><span class="keyword">int</span> n=<span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(s[i]!=s[n-i<span class="number">-1</span>])&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;不是回文串&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;是回文串&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="统计字母数字其他字符个数"><a href="#统计字母数字其他字符个数" class="headerlink" title="统计字母数字其他字符个数"></a>统计字母数字其他字符个数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">100</span>],c;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,k=<span class="number">0</span>,m=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((c=getchar())!=<span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(c&gt;=<span class="number">65</span>&amp;&amp;c&lt;=<span class="number">90</span>||c&gt;=<span class="number">97</span>&amp;&amp;c&lt;=<span class="number">122</span>)</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">j++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">k++;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">m++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;字母%d个,数字%d个,空格%d个，其他字符%d个&quot;</span>,i,j,k,m);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">15</span>]=&#123;<span class="number">15</span>,<span class="number">14</span>,<span class="number">13</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> t,s=<span class="number">-1</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">0</span>,r=<span class="number">14</span>;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line"><span class="keyword">int</span> m=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(a[m]==t)&#123;</span><br><span class="line">s=m;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a[m]&gt;t)l=m+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> r=m<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(s==<span class="number">-1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;查无此数&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;第%d个元素&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n-i<span class="number">-1</span>;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>])&#123;</span><br><span class="line"><span class="keyword">int</span> t=a[j];</span><br><span class="line">a[j]=a[j+<span class="number">1</span>];</span><br><span class="line">a[j+<span class="number">1</span>]=t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; len - <span class="number">1</span> ; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> min = i;</span><br><span class="line"><span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; len; j++)</span><br><span class="line"><span class="keyword">if</span> (a[j] &lt; a[min])</span><br><span class="line">min = j;</span><br><span class="line"><span class="keyword">if</span>(min!=i)&#123;</span><br><span class="line"><span class="keyword">int</span> t=a[min];</span><br><span class="line">a[min]=a[i];</span><br><span class="line">a[i]=t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="1-合并磁盘A-B-各存放一行字母-，放到C中"><a href="#1-合并磁盘A-B-各存放一行字母-，放到C中" class="headerlink" title="1. 合并磁盘A,B (各存放一行字母)，放到C中"></a>1. 合并磁盘A,B (各存放一行字母)，放到C中</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 打开a文件，读取a的数据，暂时存起来char,str[Maxn]</span></span><br><span class="line"><span class="comment">2. 打开b文件，读取b的数据，暂时存起来char,str[Maxn]</span></span><br><span class="line"><span class="comment">3. 排序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">if</span>((fp=fopen(<span class="string">&quot;A.txt&quot;</span>,<span class="string">&quot;r&quot;</span>))==<span class="literal">NULL</span>)<span class="comment">//打开 test1 文件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t open file!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    a[i]=fgetc(fp);<span class="comment">//把 fp 所指向的文件 test2 中的第一个字符读入到数组a[0]</span></span><br><span class="line">    <span class="keyword">while</span>(a[i]!=EOF)<span class="comment">//若第一个字符不是结束符 EOF，则继续把指针 fp 指向的文件test1 中的字符逐个读入到数组 a，直至遇到标识符 EOF 结束循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(a[i]);</span><br><span class="line">        i++;</span><br><span class="line">        a[i]=fgetc(fp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">if</span>((fp=fopen(<span class="string">&quot;B.txt&quot;</span>,<span class="string">&quot;r&quot;</span>))==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t open file!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    a[i]=fgetc(fp);<span class="comment">//把 fp 所指向的文件 test2 中的第一个字符读入到数组a[0]</span></span><br><span class="line">    <span class="keyword">while</span>(a[i]!=EOF)<span class="comment">//若第一个字符不是结束符 EOF，则继续把指针 fp 指向的文件test1 中的字符逐个读入到数组 a，直至遇到标识符 EOF 结束循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(a[i]);</span><br><span class="line">        i++;</span><br><span class="line">        a[i]=fgetc(fp);</span><br><span class="line">    &#125;</span><br><span class="line">    a[i]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n=i;<span class="comment">//此时 n 为数组 a 的长度</span></span><br><span class="line">    <span class="keyword">int</span> j,k,t;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)<span class="comment">//对数组 a 进行直接选择排序</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;a[j])</span><br><span class="line">            &#123;</span><br><span class="line">                t=a[i];</span><br><span class="line">                a[i]=a[j];</span><br><span class="line">                a[j]=t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((fp=fopen(<span class="string">&quot;C.txt&quot;</span>,<span class="string">&quot;w&quot;</span>))==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t open file!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        fputc(a[i],fp);<span class="comment">//在循环里，这条语句把数组 a 的所有字符写到文件指针变量fp 所指向的文件 C.txt 中</span></span><br><span class="line">        <span class="built_in">putchar</span>(a[i]);<span class="comment">//在循环里，这条语句把数组 a 的所有字符显示到屏幕上i++;</span></span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);<span class="comment">//关闭文件 test3，防止它被误用</span></span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-文件处理-姓名输入"><a href="#2-文件处理-姓名输入" class="headerlink" title="2.  文件处理:姓名输入"></a>2.  文件处理:姓名输入</h3><p>下面程序的功能是从键盘接受姓名（例如：输入”ZHANG SAN”），在文件”try.dat”中查 找，若文件中已经存入了刚输入的姓名，则显示提示信息；若文件中没有刚输入的姓名，则将该 姓名存入文件。要求：</p><p>⑴若磁盘文件”try.dat”，已存在，则要保留文件中原来的信息；若文件”try.dat” 不存在，则在磁盘上建立一个新文件；</p><p>⑵当输入的姓名为空时（长度为 0），结束程序。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">FILE *fp;</span><br><span class="line"><span class="keyword">int</span> flag;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">30</span>],data[<span class="number">30</span>];</span><br><span class="line"><span class="keyword">if</span>((fp=fopen(<span class="string">&quot;try.dat&quot;</span>,<span class="string">&quot;a+&quot;</span>))==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t open&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;enter name&quot;</span>);</span><br><span class="line">gets(name);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strlen</span>(name)==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">strcat</span>(name,<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">rewind(fp);</span><br><span class="line">flag=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(flag&amp;&amp;(fgets(data,<span class="number">30</span>,fp))!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(data,name)==<span class="number">0</span>)&#123;</span><br><span class="line">flag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag)&#123;</span><br><span class="line"><span class="built_in">fputs</span>(name,fp);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;data error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">while</span>(ferror(fp)==<span class="number">0</span>);</span><br><span class="line">fclose(fp);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-文件处理：检索关键字"><a href="#3-文件处理：检索关键字" class="headerlink" title="3. 文件处理：检索关键字"></a>3. 文件处理：检索关键字</h3><p>以字符流形式读入一个文件，从文件中检索出六种Ｃ语言的关键字，并统计、 输出每种关键字在文件中出现的次数。本程序中规定：单词是一个以空格或’\t’、 ‘\n’结束的字符串 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line">FILE *cp;</span><br><span class="line"><span class="keyword">char</span> fname[<span class="number">20</span>], buf[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">char</span> word[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line">&#125;keyword[]=&#123; <span class="string">&quot;if&quot;</span>, <span class="number">0</span>, <span class="string">&quot;char&quot;</span>, <span class="number">0</span>, <span class="string">&quot;int&quot;</span>, <span class="number">0</span>, <span class="string">&quot;else&quot;</span>, <span class="number">0</span>, <span class="string">&quot;while&quot;</span>, <span class="number">0</span>, <span class="string">&quot;return&quot;</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getword</span> <span class="params">(FILE *fp)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">while</span>((c=getc(fp)) != EOF &amp;&amp; (c==<span class="string">&#x27; &#x27;</span>||c==<span class="string">&#x27;\t&#x27;</span>||c==<span class="string">&#x27;\n&#x27;</span>));</span><br><span class="line"><span class="keyword">if</span>(c==EOF) </span><br><span class="line"><span class="keyword">return</span> (<span class="literal">NULL</span>) ;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">buf[i++]=c;</span><br><span class="line"><span class="keyword">while</span>((c = fgetc(fp))!=EOF&amp;&amp; c!= <span class="string">&#x27; &#x27;</span> &amp;&amp; c!= <span class="string">&#x27;\t&#x27;</span> &amp;&amp; c!= <span class="string">&#x27;\n&#x27;</span> )</span><br><span class="line">buf[i++] = c;</span><br><span class="line">buf[i]= <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lookup</span><span class="params">(<span class="keyword">char</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">char</span> *q, *s;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;num;i++)&#123; </span><br><span class="line">q = &amp;keyword[i].word[<span class="number">0</span>] ;</span><br><span class="line">s=p;</span><br><span class="line"><span class="keyword">while</span>( *s &amp;&amp; (*s==*q) )&#123; </span><br><span class="line">s++; q++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( *s==*q )&#123; </span><br><span class="line">keyword[i].count++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">char</span> *word;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Input file name:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, fname);</span><br><span class="line"><span class="keyword">if</span>((cp=fopen(fname, <span class="string">&quot;r&quot;</span>)) ==<span class="literal">NULL</span> )</span><br><span class="line">&#123; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;File open error: %s\n&quot;</span>, fname);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">num = <span class="keyword">sizeof</span>(keyword)/<span class="keyword">sizeof</span>(struct key);</span><br><span class="line"><span class="keyword">while</span>((word=getword(cp))!=<span class="literal">NULL</span>)</span><br><span class="line">lookup(word);</span><br><span class="line">fclose(cp);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;keyword:%-20scount=%d\n&quot;</span>,keyword[i].word,keyword[i].count);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-文件处理：读入二进制"><a href="#4-文件处理：读入二进制" class="headerlink" title="4. 文件处理：读入二进制"></a>4. 文件处理：读入二进制</h3><p>下面程序的功能是将从终端上读入的 10 个整数以二进制方式写入名为”bi.dat”的新文件 中。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">FILE *fp; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j; </span><br><span class="line"><span class="keyword">if</span>((fp=fopen(<span class="string">&quot;bi.dat&quot;</span>, <span class="string">&quot;wb&quot;</span> )) == <span class="literal">NULL</span> ) </span><br><span class="line"><span class="built_in">exit</span> (<span class="number">0</span>); </span><br><span class="line"><span class="keyword">for</span>( i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;j ); </span><br><span class="line">fwrite(&amp;j,<span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">1</span>, fp); </span><br><span class="line">&#125; </span><br><span class="line">fclose(fp);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-文件处理-字符串大小写转换"><a href="#5-文件处理-字符串大小写转换" class="headerlink" title="5.  文件处理:字符串大小写转换"></a>5.  文件处理:字符串大小写转换</h3><p>下面程序的功能是键盘上输入一个字符串，把该字符串中的小写字母转换为大写字母， 输出到文件 test.txt 中，然后从该文件读出字符串并显示出来。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">100</span>]; </span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>; </span><br><span class="line">FILE *fp; </span><br><span class="line"><span class="keyword">if</span>((fp=fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;w&quot;</span>))==<span class="literal">NULL</span>) &#123; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Can&#x27;t open the file.\n&quot;</span>); </span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Input a string:\n&quot;</span>); </span><br><span class="line">gets(str); </span><br><span class="line"><span class="keyword">while</span>(str[i])&#123;</span><br><span class="line"><span class="keyword">if</span>(str[i]&gt;= <span class="string">&#x27;a&#x27;</span>&amp;&amp;str[i]&lt;= <span class="string">&#x27;z&#x27;</span>) </span><br><span class="line">str[i]= str[i]<span class="number">-32</span> ; </span><br><span class="line">fputc(str[i],fp); i++; </span><br><span class="line">&#125; </span><br><span class="line">fclose(fp); </span><br><span class="line">fp=fopen(<span class="string">&quot;test.txt&quot;</span>,<span class="string">&quot;r&quot;</span>); </span><br><span class="line">fgets(str,<span class="built_in">strlen</span>(str)+<span class="number">1</span>,fp); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,str); </span><br><span class="line">fclose(fp);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据结构部分"><a href="#数据结构部分" class="headerlink" title="数据结构部分"></a>数据结构部分</h2><h3 id="将a和b两个链表合并，链表包括学号，成绩，按学号升序排列"><a href="#将a和b两个链表合并，链表包括学号，成绩，按学号升序排列" class="headerlink" title="将a和b两个链表合并，链表包括学号，成绩，按学号升序排列"></a>将a和b两个链表合并，链表包括学号，成绩，按学号升序排列</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(LinkList A,LinkList B,LinkList &amp;C)</span></span>&#123;</span><br><span class="line">    LNode *p=A-&gt;next;</span><br><span class="line">    LNode *q=B-&gt;next;</span><br><span class="line">    C=A;</span><br><span class="line">    C-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    LNode *r=C;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;q!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data&lt;q-&gt;data)&#123;</span><br><span class="line">            r-&gt;next=p;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            r=r-&gt;next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            r-&gt;next=q;</span><br><span class="line">            q=q-&gt;next;</span><br><span class="line">            r=r-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)r-&gt;next=p;</span><br><span class="line">    <span class="keyword">if</span>(q!=<span class="literal">NULL</span>)r-&gt;next=q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;C代码复盘&quot;&gt;&lt;a href=&quot;#C代码复盘&quot; class=&quot;headerlink&quot; title=&quot;C代码复盘&quot;&gt;&lt;/a&gt;C代码复盘&lt;/h1&gt;&lt;h2 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    
    <category term="考研" scheme="https://insistgang.github.io/tags/%E8%80%83%E7%A0%94/"/>
    
    <category term="C语言" scheme="https://insistgang.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>测试卷1.0</title>
    <link href="https://insistgang.github.io/posts/241af10e.html"/>
    <id>https://insistgang.github.io/posts/241af10e.html</id>
    <published>2022-09-11T14:10:14.000Z</published>
    <updated>2022-09-15T12:13:23.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="测试卷1-0"><a href="#测试卷1-0" class="headerlink" title="测试卷1.0"></a>测试卷1.0</h2><h3 id="1-旧事重提"><a href="#1-旧事重提" class="headerlink" title="1. 旧事重提"></a>1. 旧事重提</h3><p>二分法实现幂函数x的n次方pow(x,n)</p><p>这里的二分法是指减少乘法的次数，把重复的运算省去。我要求x的n次方，那么先求x的n/2次方，然后两个相乘起来。如此递归下去。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">            n=n<span class="number">-1</span>;</span><br><span class="line">            t*=x;</span><br><span class="line">        &#125;</span><br><span class="line">        x*=x;</span><br><span class="line">        n/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">fun</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)<span class="comment">//递归结束条件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">double</span> half;</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">1</span>)&#123;<span class="comment">//递归转移方程</span></span><br><span class="line">        half=<span class="built_in">fun</span>(x,n/<span class="number">2</span>);<span class="comment">//x的n/2次方</span></span><br><span class="line">        <span class="keyword">return</span> x*half*half;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        half=<span class="built_in">fun</span>(x,n/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> half*half;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">pow</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> result=<span class="built_in">fun</span>(x,n);</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>)</span><br><span class="line">        result=<span class="number">1</span>/result;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-有两个n维向量相乘，求其点乘的最小值"><a href="#2-有两个n维向量相乘，求其点乘的最小值" class="headerlink" title="2. 有两个n维向量相乘，求其点乘的最小值"></a>2. 有两个n维向量相乘，求其点乘的最小值</h3><p>两个n维的向量，相乘的点是指将向量对应维度的乘积相加，但是我们可以将向量维度交换下可以得到更小的向量点乘，例如3维向量：1,3,-5和4,-2,-1最小向量点乘为-27，即将维度变为：3,1,-5和-2,-1,4。只需要把第一个向量进行全排列，就可以得到所有的乘积</p><p>程序设计要求：输入一个整数n为向量的维度，然后输入两个n维度的向量，用空格区别向量元素，输出为一行，包含一个整数，为最小的点乘。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 进行全排列:三行代码 交换 进入下一层 再交换</span></span><br><span class="line"><span class="comment">2. 当排列好之后进行点乘，当结果小于当前最小值时候进行更新</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxnn=<span class="number">1e9</span>+<span class="number">1</span>;<span class="comment">//数值的最大值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn=<span class="number">1e2</span>+<span class="number">1</span>;<span class="comment">//数组的最大值</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[Maxn],b[Maxn];</span><br><span class="line"><span class="keyword">int</span> sum;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t&gt;n)&#123;</span><br><span class="line">        sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            sum+=a[i]*b[i];</span><br><span class="line">        <span class="keyword">if</span>(sum&lt;ans)</span><br><span class="line">            ans=sum;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=t;i&lt;=n;i++)<span class="comment">//从第t个元素交换到第n的元素</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(a[t],a[i]);</span><br><span class="line">            <span class="built_in">backtrack</span>(t+<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">swap</span>(a[t],a[i]);<span class="comment">//回溯，使得a[t]的值不变</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;b[i];</span><br><span class="line">    <span class="built_in">backtrack</span>(<span class="number">1</span>);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-二叉排序树删除某个结点。要求用非递归算法并释放掉该结点。"><a href="#3-二叉排序树删除某个结点。要求用非递归算法并释放掉该结点。" class="headerlink" title="3. 二叉排序树删除某个结点。要求用非递归算法并释放掉该结点。"></a>3. 二叉排序树删除某个结点。要求用非递归算法并释放掉该结点。</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 首先判断这个结点是否有右子树；无：直接用这个结点的左子树覆盖当前结点</span></span><br><span class="line"><span class="comment">2. 判断一下是否有左子树；无：直接用右子树来覆盖当前结点</span></span><br><span class="line"><span class="comment">3. 当左右子树都存在时候，从p的左子树的最右结点（最大值）赋值给当前结点p，左子树中的最右结点给删除。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(BiTree *p)</span></span>&#123;</span><br><span class="line">    BiTree *q,*s;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;rchild==<span class="literal">NULL</span>)<span class="comment">/*左子树空只需要重接它的左子树（待删节点是叶子也走此分支）*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        p=p-&gt;lchild;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">NULL</span>) <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;lchild==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        p=p-&gt;rchild;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        q=p;</span><br><span class="line">        s=p-&gt;lchild;</span><br><span class="line">        <span class="keyword">while</span>(s-&gt;rchild)&#123;</span><br><span class="line">            q=s;</span><br><span class="line">            s=s-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;data=s-&gt;data;<span class="comment">//s指向被删结点的直接前驱</span></span><br><span class="line">        <span class="keyword">if</span>(q!=p)<span class="comment">//s有右子树</span></span><br><span class="line">        &#123;</span><br><span class="line">            q-&gt;rchild=s-&gt;lchild;<span class="comment">//重接q的右子树</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            q-&gt;lchild=s-&gt;lchild;<span class="comment">//重接q的左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-用回溯法来解决装载问题。"><a href="#4-用回溯法来解决装载问题。" class="headerlink" title="4. 用回溯法来解决装载问题。"></a>4. 用回溯法来解决装载问题。</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span><span class="comment">//子集树</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn=<span class="number">1e3</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> c;<span class="comment">//第一个轮船装载量</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> w[Maxn];</span><br><span class="line"><span class="keyword">int</span> r;<span class="comment">//剩余重量</span></span><br><span class="line"><span class="keyword">int</span> x[Maxn];<span class="comment">//记录n个集装箱是否被装入</span></span><br><span class="line"><span class="keyword">int</span> cw;<span class="comment">//当前载重量</span></span><br><span class="line"><span class="keyword">int</span> bestw;<span class="comment">//最优载重量</span></span><br><span class="line"><span class="keyword">int</span> bestx[Maxn];<span class="comment">//最优装载情况</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t&gt;n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cw&gt;bestw)&#123;</span><br><span class="line">            bestw=cw;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">                bestx[i]=x[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    r-=w[t];<span class="comment">//搜索左子树 i---i+1---n</span></span><br><span class="line">    <span class="keyword">if</span>(vw+w[t]&lt;=c)&#123;</span><br><span class="line">        cw+=w[t];</span><br><span class="line">        x[t]=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">backtrack</span>(t+<span class="number">1</span>);</span><br><span class="line">        cw-=w[t];<span class="comment">//回溯到上一层</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r+cw&gt;bestw)<span class="comment">//当前载重量加上剩余集装箱的重量大于最优质才能进行右子树</span></span><br><span class="line">    &#123;</span><br><span class="line">        x[t]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">backtrack</span>(t+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    r+=w[t];<span class="comment">//回溯到上一层</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cin&gt;&gt;w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        r+=w[i];</span><br><span class="line">    <span class="built_in">backtrack</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        cout&lt;&lt;bestx[i]&lt;&lt;<span class="string">&quot;\t&quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-二叉树的带权路径长度-WPL-是二叉树中所有叶结点的带权路径长度之和。给定一棵二叉树T，才用二叉链表存储，结点结构为：left-weight-right，其中叶结点的weight域保存该结点的非负权值。设root为指向T的根节点的指针，请设计求T的WPL的算法。要求："><a href="#5-二叉树的带权路径长度-WPL-是二叉树中所有叶结点的带权路径长度之和。给定一棵二叉树T，才用二叉链表存储，结点结构为：left-weight-right，其中叶结点的weight域保存该结点的非负权值。设root为指向T的根节点的指针，请设计求T的WPL的算法。要求：" class="headerlink" title="5. 二叉树的带权路径长度(WPL)是二叉树中所有叶结点的带权路径长度之和。给定一棵二叉树T，才用二叉链表存储，结点结构为：left weight right，其中叶结点的weight域保存该结点的非负权值。设root为指向T的根节点的指针，请设计求T的WPL的算法。要求："></a>5. 二叉树的带权路径长度(WPL)是二叉树中所有叶结点的带权路径长度之和。给定一棵二叉树T，才用二叉链表存储，结点结构为：left weight right，其中叶结点的weight域保存该结点的非负权值。设root为指向T的根节点的指针，请设计求T的WPL的算法。要求：</h3><ol><li>给出算法的基本设计思想</li><li>使用C或C++语言，给出二叉树结点的数据类型定义</li><li>根据设计思想，采用C或C++语言描述算法，关键之处给出注释</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 本问题采用递归算法实现，根据定义:</span></span><br><span class="line"><span class="comment">二叉树的WPL值=树中全部也结点的带权路径长度之和</span></span><br><span class="line"><span class="comment">=根结点左子树中全部叶节点的带权路径长度之和+根结点右子树中全部叶节点的带权路径长度之和</span></span><br><span class="line"><span class="comment">叶节点的带权路径长度=该点的weight域的值*该节点的深度 </span></span><br><span class="line"><span class="comment">设根结点的深度为0，若某结点的深度为d时，则其孩子结点的深度为d+1。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BTree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">    BTree *left,*right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WPL</span><span class="params">(BTree *root)</span><span class="comment">//根据WPL的定义采用递归算法实现</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">WPL1</span>(root,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WPL1</span><span class="params">(BTree *root,<span class="keyword">int</span> d)</span><span class="comment">//d为结点的深度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span>&amp;&amp;root-&gt;right==<span class="literal">NULL</span>)<span class="comment">//递归结束调剂</span></span><br><span class="line">        <span class="keyword">return</span> root-&gt;weight*d;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">WPL1</span>(root-&gt;left,d+<span class="number">1</span>)+<span class="built_in">WPL1</span>(root-&gt;right,d+<span class="number">1</span>);<span class="comment">//递归转移方程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6-二路插入排序是将待排关键字序列r-1…n-中关键字分二路分别按序列插入到辅助向量d-1-n-前半部和后半部，其原则为，先将r-1-赋为d-1-，再从r-2-记录开始分二路插入。编写实现二路插入排序算法。"><a href="#6-二路插入排序是将待排关键字序列r-1…n-中关键字分二路分别按序列插入到辅助向量d-1-n-前半部和后半部，其原则为，先将r-1-赋为d-1-，再从r-2-记录开始分二路插入。编写实现二路插入排序算法。" class="headerlink" title="6. 二路插入排序是将待排关键字序列r[1…n]中关键字分二路分别按序列插入到辅助向量d[1..n]前半部和后半部，其原则为，先将r[1]赋为d[1]，再从r[2]记录开始分二路插入。编写实现二路插入排序算法。"></a>6. 二路插入排序是将待排关键字序列r[1…n]中关键字分二路分别按序列插入到辅助向量d[1..n]前半部和后半部，其原则为，先将r[1]赋为d[1]，再从r[2]记录开始分二路插入。编写实现二路插入排序算法。</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">二路插入排序是对直接插入的改进，特别注意在前半部插入时元素的移动。</span></span><br><span class="line"><span class="comment">1.判断待插入的元素是否大于 d[1];是:插入到 d[1]后面，否:插入到 d[1]前面</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn=<span class="number">1e3</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> r[Maxn],d[Maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">d[<span class="number">1</span>]=r[<span class="number">1</span>];<span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">int</span> first=<span class="number">1</span>,<span class="keyword">final</span>=<span class="number">1</span>;<span class="comment">//first 指前半部”最前面”的下标;final 指后半部”最后面”的下标</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)<span class="comment">//初始化 d[1]=r[1];first=1,final=1</span></span><br><span class="line">        <span class="keyword">if</span>(r[i]&gt;d[<span class="number">1</span>])<span class="comment">//插入后部</span></span><br><span class="line">        &#123;</span><br><span class="line">            low=<span class="number">1</span>;</span><br><span class="line">            high=<span class="keyword">final</span>;</span><br><span class="line">            <span class="keyword">while</span>(low&lt;=high)<span class="comment">//折半查找插入位置</span></span><br><span class="line">            &#123;</span><br><span class="line">                m=(low+high)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(r[i]&lt;d[m])</span><br><span class="line">                high=m<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                low=m+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="comment">//最后跳出循环时 low&gt;high high+1 是插入的位置</span></span><br><span class="line">    <span class="keyword">for</span>(j=<span class="keyword">final</span>;j&gt;=high+<span class="number">1</span>;j--)<span class="comment">//移动元素</span></span><br><span class="line">                d[j+<span class="number">1</span>]=d[j];</span><br><span class="line">    d[high+<span class="number">1</span>]=r[i];<span class="comment">//插入有序位置</span></span><br><span class="line">    <span class="keyword">final</span>++;<span class="comment">//后半部的下标+1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//插入前部</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(first==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            first=n;</span><br><span class="line">            d[n]=r[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            low=frst;</span><br><span class="line">            high=n;</span><br><span class="line">            <span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">            &#123;</span><br><span class="line">                m=(low+high)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(r[i]&lt;d[m])</span><br><span class="line">                    high=m<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    low=m+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=first;j&lt;=high;j++)</span><br><span class="line">            d[j<span class="number">-1</span>]=d[j];</span><br><span class="line">            d[high]=r[i];first--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r[<span class="number">1</span>]=d[first];<span class="comment">//存储最小值</span></span><br><span class="line">    <span class="keyword">for</span>(i=first%n+<span class="number">1</span>,j=<span class="number">2</span>;i!=first;i=i%n+<span class="number">1</span>,j++)<span class="comment">//通过循环赋值使得 r 中数据从小到大排序</span></span><br><span class="line">        r[j]=d[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cin&gt;&gt;r[i];</span><br><span class="line">    <span class="built_in">fun</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    cout&lt;&lt;r[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-钱币找零问题"><a href="#7-钱币找零问题" class="headerlink" title="7. 钱币找零问题"></a>7. 钱币找零问题</h3><p>指定币值和相应数量，用最少的数量凑齐某金额</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">100</span>][maxn]; <span class="comment">// dp[i][j] 表示用前 i 种钱币 凑 j 元的最少数量</span></span><br><span class="line"><span class="keyword">int</span> coin[maxn],num[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) cin&gt;&gt;coin[i]; <span class="comment">// 钱币面值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) cin&gt;&gt;num[i];  <span class="comment">// 钱币数量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123; <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;maxn;j++)</span><br><span class="line">            dp[i][j]=<span class="number">1e9</span>; <span class="comment">// 求最小初始化为最大</span></span><br><span class="line">        dp[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123; <span class="comment">// 枚举钱币</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=num[i];j++)&#123; <span class="comment">// 枚举钱币数量</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123; <span class="comment">// 枚举需凑 金额</span></span><br><span class="line">                <span class="keyword">if</span>(k&gt;=coin[i]*j) <span class="comment">//当前方案可以凑成 金额k</span></span><br><span class="line">                    dp[i][k]=<span class="built_in">min</span>(dp[i][k],dp[i<span class="number">-1</span>][k-coin[i]*j]+j);</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">//当前方案超过金额k，不可凑</span></span><br><span class="line">                    dp[i][k]=<span class="built_in">min</span>(dp[i][k], dp[i<span class="number">-1</span>][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">1e9</span>; <span class="comment">// 对前 i 种钱币凑 n 元取最小值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) ans=<span class="built_in">min</span>(ans,dp[i][n]);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;测试卷1-0&quot;&gt;&lt;a href=&quot;#测试卷1-0&quot; class=&quot;headerlink&quot; title=&quot;测试卷1.0&quot;&gt;&lt;/a&gt;测试卷1.0&lt;/h2&gt;&lt;h3 id=&quot;1-旧事重提&quot;&gt;&lt;a href=&quot;#1-旧事重提&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
    <category term="datastruct" scheme="https://insistgang.github.io/tags/datastruct/"/>
    
    <category term="algorithm" scheme="https://insistgang.github.io/tags/algorithm/"/>
    
    <category term="真题" scheme="https://insistgang.github.io/tags/%E7%9C%9F%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>8512021</title>
    <link href="https://insistgang.github.io/posts/cf1b292.html"/>
    <id>https://insistgang.github.io/posts/cf1b292.html</id>
    <published>2022-09-11T13:56:58.000Z</published>
    <updated>2022-09-15T14:28:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="851-2021"><a href="#851-2021" class="headerlink" title="851_2021"></a>851_2021</h2><h3 id="1-链表题"><a href="#1-链表题" class="headerlink" title="1. 链表题"></a>1. 链表题</h3><ol><li>什么是线性结构，写出线性结构的特点</li><li>写出删除链表头结点的算法</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">(1)线性结构的特点是在数据元素的非空有限集中：</span></span><br><span class="line"><span class="comment">①存在惟一的一个被称作“第一个”的数据元素和惟一的一个被称作“最后一个”的数据元素；</span></span><br><span class="line"><span class="comment">②除第一个之外，集合中的每个数据元素均只有一个前驱；除最后一个之外，集合中的每一个数据元素均只有一个后继。线性结构的数据元素之间存在一对一的线性关系。线性结构拥有两种不同的存储结构，即顺序存储结构和链式存储结构。顺序存储的线性表称为顺序表，顺序表中的存储元素是连续的，链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地址信息。</span></span><br><span class="line"><span class="comment">线性结构中存在两种操作受限的使用场景，即队列和栈。栈的操作只能在线性表的一端进行，就是我们常说的先进后出（FILO），队列的插入操作在线性表的一端进行而其他操作在线性表的另一端进行，先进先出（FIFO），由于线性结构存在两种存储结构，因此队列和栈各存在两个实现方式。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Node *<span class="title">DeleteHead</span><span class="params">(Node *pHead)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(PHead==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">//链表为空表,返回NULL</span></span><br><span class="line">    Node *pTemp = pHead-&gt;next;<span class="comment">//pTemp 指向表头的后一个结点</span></span><br><span class="line">    <span class="built_in">free</span>(pHead);<span class="comment">//直接删除表头，释放头节点的内存</span></span><br><span class="line">    <span class="keyword">if</span>(pTemp==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">//原表只有表头一个几点，故删除后只剩下NULL</span></span><br><span class="line">    pHead=pTemp;</span><br><span class="line">    <span class="keyword">return</span> pHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-如图所示，阴影部分为边界像素，像素点着色算法的原理如下"><a href="#2-如图所示，阴影部分为边界像素，像素点着色算法的原理如下" class="headerlink" title="2. 如图所示，阴影部分为边界像素，像素点着色算法的原理如下"></a>2. 如图所示，阴影部分为边界像素，像素点着色算法的原理如下</h3><p>我们先选取s点，将其置为区域中的已知颜色，再按右上左下的方式将其邻接点着色</p><p><img src="../../images/123.png"></p><ol><li>栈是什么？有什么特点？</li><li>请描述该算法的过程</li><li>画图展示该算法的运行过程</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">(1)栈也是用来存储逻辑关系为“一对一”数据的线性存储结构，同顺序表和链表一样。</span></span><br><span class="line"><span class="comment">特点：</span></span><br><span class="line"><span class="comment">①栈只能从表的一端存取数据，另一端是封闭的；</span></span><br><span class="line"><span class="comment">②在栈中，无论是存数据还是取数据，都必须遵循“先进后出”的原则，即最先进栈的元素最后出栈</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">(2)算法步骤：</span></span><br><span class="line"><span class="comment">1.将s点入栈</span></span><br><span class="line"><span class="comment">2.将栈顶元素出栈</span></span><br><span class="line"><span class="comment">3.探索栈顶元素周围按照右上左下的顺序判断是否是合法的活结点，合法的活结点必须符合：</span></span><br><span class="line"><span class="comment">（1）该点是像素点而不是边界；（2）该点未被染色</span></span><br><span class="line"><span class="comment">4.将合法的活结点入栈</span></span><br><span class="line"><span class="comment">重复执行2-4步骤，直至栈空，表示所有像素已经着色。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="3-综合快速排序，回答下面问题："><a href="#3-综合快速排序，回答下面问题：" class="headerlink" title="3. 综合快速排序，回答下面问题："></a>3. 综合快速排序，回答下面问题：</h3><ol><li>叙述冒泡排序的过程</li><li>设计实例，叙述快速排序的过程</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">(1)</span></span><br><span class="line"><span class="comment">比较两个相邻的元素，将值大的元素交换到右边。</span></span><br><span class="line"><span class="comment">一趟比较过程：依次比较相邻的两个数，将比较小的数放在前面，比较大的数放在后面。</span></span><br><span class="line"><span class="comment">①第一次比较：首先比较第一和第二个数，将小数放在前面，将大数放在后面。</span></span><br><span class="line"><span class="comment">②比较第 2 和第 3 个数，将小数 放在前面，大数放在后面。</span></span><br><span class="line"><span class="comment">③如此继续，知道比较到最后的两个数，将小数放在前面，大数放在后面，重复步骤，直至全部排序完成</span></span><br><span class="line"><span class="comment">④在上面一趟比较完成后，最后一个数一定是数组中最大的一个数，所以在比较第二趟的时候，最后一个数是不参加比较的。</span></span><br><span class="line"><span class="comment">⑤在第二趟比较完成后，倒数第二个数也一定是数组中倒数第二大数，所以在第三趟的比较中，最后两个数是不参与比较的。</span></span><br><span class="line"><span class="comment">⑥依次类推，每一趟比较次数减少依次</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">49, 38, 65, 97, 76, 13, 27</span></span><br><span class="line"><span class="comment">首先将第一个元素49作为基准</span></span><br><span class="line"><span class="comment">设变量j从27从右向左找比基准小的元素，设变量i从49开始向右找到比基准大的元素，</span></span><br><span class="line"><span class="comment">找到27和65后，交换他们则第一次交换后：49, 38, 27, 97, 76, 13, 65。</span></span><br><span class="line"><span class="comment">继续移动ij找到对应元素并交换多次交换后序列为：49, 38, 27, 13, 76, 97, 65，</span></span><br><span class="line"><span class="comment">并且ij相遇在元素13把基准元素和ij相遇所在位置交换:13,38, 27, 49, 76, 97, 65</span></span><br><span class="line"><span class="comment">此时，49左边小于49，右边大于49，可以把把问题变成两个更小规模的相同的子问题，</span></span><br><span class="line"><span class="comment">继续递归下去，直到区间为1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="4-结合计算机算法设计与分析"><a href="#4-结合计算机算法设计与分析" class="headerlink" title="4. 结合计算机算法设计与分析"></a>4. 结合计算机算法设计与分析</h3><ol><li>什么是动态规划？动态规划和分治法的区别是什么？</li><li>举例说明，动态规划求解最优化问题的过程？</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">动态规划：当前需要求解的问题可以分解为多个子问题，问题的最优解如果可以由子问题的最优解推导得到，则可以先求解子问题的最优解，再构造原问题的最优解；若子问题有较多的重复出现，为此动态规划仅解决每个子问题一次，从而减少计算量，即一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查询。最后则自底向上从最终子问题向原问题逐步求解。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">分治算法是把原问题分解为若干独立的子问题，子问题与子问题间相互独立，不存在重复求解子问题的情况，自顶向下求解子问题，合并子问题的解，从而得到原问题的解。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">举例为0-1背包问题：</span></span><br><span class="line"><span class="comment">在 N 件物品取出若干件放在容量为 W 的背包里，每件物品的体积为 W1，W2……Wn（Wi 为整数），与之相对应的价值为 P1,P2……Pn（Pi 为整数），求背包能够容纳的最大价值。</span></span><br><span class="line"><span class="comment">像这种固定数值的组合问题，比如这个问题的 W 总容量，跟下个实例零钱问题的总钱数，都是适合用动态规划来解决的问题，对于这样的问题，动态规划的解法就是：创建一个二维数组，横坐标是从 1 开始到 W，纵坐标是组成 W 的各种元素，本题中就是指 W1，W2……Wn，数组中每个位置（i，j）的数字就是当组成元素只有 W1，W2……Wi，背包可放容量为 j 时的结果，本题中就是容纳的最大价值。所以很容易分析出，当（i，j）时，如果 Wi 能放的下，空间减小，但是会增加 Pi 的价值，如果 Wi 不能放的下，空间不变，是（i-1，j）的价值，取其中最大值就好了，即状态转化方程为能放的下，dp[i][j] = max(dp[i-1][j],dp[i-1][jw[i]]+p[i])；放不下，dp[i][j] = dp[i-1][j]；对于前面规模更小的dp[i][j]记录最优值，当要解决更大规模的问题时，可以直接O(1)查询结果，而不必自顶向下的多次求解。最后，dp[n][v]即为最终的最优值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-Fibonacci函数表达式为："><a href="#5-Fibonacci函数表达式为：" class="headerlink" title="5. Fibonacci函数表达式为："></a>5. Fibonacci函数表达式为：</h3><p>f(1)=f(2)=1;</p><p>f(n)=f(n-1)+f(n-2),(n&gt;=3，且n为N+)</p><ol><li>用递归思想写出代码，关键部分加上注释</li><li>分析算法的时间复杂度和空间复杂度</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fib</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">2</span>) <span class="comment">//递归的出口</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Fib</span>(n<span class="number">-1</span>)+<span class="built_in">Fib</span>(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">假设需要求其中的第 n 位，则可以构建二叉树，二叉树的高度是 n - 1，由我们的基础知识可以知道，一个高度为 k 的二叉树最多可以由 2^k - 1 个叶子节点，也就是递归过程函数调用的次数，所以时间复杂度为O(2^n)，而空间复杂度就是树的高度 S(n)。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="6-哈夫曼树编码自底向上实现，若定义叶子结点所在层为第一层，其父为第二层，以此类推，处在第n层的结点扫描n-1次，复杂度为o-n-2"><a href="#6-哈夫曼树编码自底向上实现，若定义叶子结点所在层为第一层，其父为第二层，以此类推，处在第n层的结点扫描n-1次，复杂度为o-n-2" class="headerlink" title="6. 哈夫曼树编码自底向上实现，若定义叶子结点所在层为第一层，其父为第二层，以此类推，处在第n层的结点扫描n-1次，复杂度为o(n^2)"></a>6. 哈夫曼树编码自底向上实现，若定义叶子结点所在层为第一层，其父为第二层，以此类推，处在第n层的结点扫描n-1次，复杂度为o(n^2)</h3><ol><li>设计能表示二叉树的链表数据结构</li><li>基于上述两种数据结构设计一个复杂度为O(n)的哈夫曼树新编码算法，可实现从树根想叶子结点编码，写出思想</li><li>编写代码实现上溢问题的算法</li><li>分析时间复杂度为什么为O(n)</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">htNode</span>//树节点的结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> symbol;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">htNode</span> *<span class="title">left</span>,*<span class="title">right</span>;</span><span class="comment">//左右孩子</span></span><br><span class="line">&#125;htNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">htNode</span>//树的结构体,树的根</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    htNode *root;</span><br><span class="line">&#125;htTree;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">将排序好的结点依次放入队列1中</span></span><br><span class="line"><span class="comment">合并两个最小的元素有三种可能，队列1中的前两个，队列2中的前两个，队列1和队列2的第一个。在三种情况下选择和最小的合并。合并后放入队列2中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">character</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch;<span class="comment">//字符</span></span><br><span class="line">    <span class="keyword">int</span> time;<span class="comment">//该字符出现的次数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(character a,character b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.time&lt;b.time;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n;<span class="comment">//有n种字母，即n个叶子节点</span></span><br><span class="line">character arr[<span class="number">30</span>];<span class="comment">//根据字母出现次数从小到大排列数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initial_work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;<span class="comment">//输入有n个叶子节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;arr[i].ch&gt;&gt;arr[i].time;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(arr,arr+n,cmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">htNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">htNode</span> *<span class="title">left</span>,*<span class="title">right</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">htNode</span>//树的结构体,树的根</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    htNode *root;</span><br><span class="line">&#125;htTree;</span><br><span class="line"></span><br><span class="line">htNode queone[<span class="number">100</span>];<span class="comment">//htNode 类型的数组，用数组模拟队列</span></span><br><span class="line"><span class="keyword">int</span> q1h,q2h;<span class="comment">//指向两个队列的队首的下标</span></span><br><span class="line">htNode quetwo[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> q1t,q2t;<span class="comment">//指向队尾的后一个</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Compare</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=y&amp;&amp;x&lt;=z)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(y&lt;=x&amp;&amp;y&lt;=z)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(z&lt;=x&amp;&amp;z&lt;=y)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">htTree <span class="title">create</span><span class="params">()</span></span>&#123;</span><br><span class="line">    htNode tep;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        tep.ch=arr[i].ch;</span><br><span class="line">        tep.value=arr[i].time;</span><br><span class="line">        tep.left=<span class="literal">NULL</span>;</span><br><span class="line">        tep.right=<span class="literal">NULL</span>;</span><br><span class="line">        queone[q1t++]=tep;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q1t-q1h+q2t-q2h&gt;<span class="number">1</span>)<span class="comment">//两个队列的元素的个数和大于1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x1=inf; <span class="keyword">int</span> x2=inf; <span class="keyword">int</span> x3=inf;</span><br><span class="line">        <span class="keyword">if</span>(q1t-q1h&gt;=<span class="number">2</span>)<span class="comment">//队列1中有两个以上元素</span></span><br><span class="line">        x1=queone[q1h].value+queone[q1h+<span class="number">1</span>].value;</span><br><span class="line">        <span class="keyword">if</span>(q2t-q2h&gt;=<span class="number">2</span>)<span class="comment">//队列2中有两个以上元素</span></span><br><span class="line">        x2=quetwo[q2h].value+quetwo[q2h+<span class="number">1</span>].value;</span><br><span class="line">        <span class="keyword">if</span>(q1t-q1h&gt;=<span class="number">1</span>&amp;&amp;q2t-q2h&gt;=<span class="number">1</span>)</span><br><span class="line">        x3=queone[q1h].value+quetwo[q2h].value;</span><br><span class="line">        <span class="keyword">int</span> Result=<span class="built_in">Compare</span>(x1,x2,x3);</span><br><span class="line">        <span class="keyword">if</span>(Result==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tep.value=x1;</span><br><span class="line">            tep.left=&amp;queone[q1h];</span><br><span class="line">            q1h++;</span><br><span class="line">            tep.right=&amp;queone[q1h];</span><br><span class="line">            q1h++; <span class="comment">//弹出队列1前两个</span></span><br><span class="line">            quetwo[q2t++]=tep;<span class="comment">//把合并的结果存到队列2中</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Result==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tep.value=x2;</span><br><span class="line">            tep.left=&amp;quetwo[q2h];</span><br><span class="line">            q2h++;</span><br><span class="line">            tep.right=&amp;quetwo[q2h];</span><br><span class="line">            q2h++; <span class="comment">//弹出队列2前两个</span></span><br><span class="line">            quetwo[q2t++]=tep;<span class="comment">//把合并的结果存到队列2中</span></span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            tep.value=x3;</span><br><span class="line">            tep.left=&amp;queone[q1h];</span><br><span class="line">            q1h++;</span><br><span class="line">            tep.right=&amp;quetwo[q2h];</span><br><span class="line">            q2h++; <span class="comment">//队列1 2 各弹出一个</span></span><br><span class="line">            quetwo[q2t++]=tep;<span class="comment">//把合并的结果存到队列2中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    htTree tree;</span><br><span class="line">    tree.root=&amp;quetwo[q2h];</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(htNode *node,<span class="keyword">int</span> step)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node-&gt;left==<span class="literal">NULL</span>&amp;&amp;node-&gt;right==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    ans+=(node-&gt;value)*step;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(node-&gt;left!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">dfs</span>(node-&gt;left,step+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(node-&gt;right!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">dfs</span>(node-&gt;right,step+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">构造哈夫曼树时，每次合并一个元素的代价是3，共有n次合并，时间复杂度是3n，也就是O(n)。</span></span><br><span class="line"><span class="comment">计算哈夫曼的代价值时，只需一次dfs，求和叶子节点的花费即可。时间复杂度也是O(n)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="7-一个由n个点构成的图，用n-n的矩阵来表示，矩阵由0或1组成，i行j列为0表示i点和j点之间无边，否则i和j之间右边，请你设计算法判断任意两点是否连通。"><a href="#7-一个由n个点构成的图，用n-n的矩阵来表示，矩阵由0或1组成，i行j列为0表示i点和j点之间无边，否则i和j之间右边，请你设计算法判断任意两点是否连通。" class="headerlink" title="7. 一个由n个点构成的图，用n*n的矩阵来表示，矩阵由0或1组成，i行j列为0表示i点和j点之间无边，否则i和j之间右边，请你设计算法判断任意两点是否连通。"></a>7. 一个由n个点构成的图，用n*n的矩阵来表示，矩阵由0或1组成，i行j列为0表示i点和j点之间无边，否则i和j之间右边，请你设计算法判断任意两点是否连通。</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">bool</span> Graph[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">101</span>];<span class="comment">//标记数组</span></span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;<span class="comment">//ans=1 表示连同，否则不连通</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> Target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(now==Target)&#123;</span><br><span class="line">        ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Graph[now][i]&amp;&amp;!vis[i])<span class="comment">//now 可达 且该店未访问</span></span><br><span class="line">        &#123;</span><br><span class="line">            vis[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(i,Target);</span><br><span class="line">            vis[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            cin&gt;&gt;Graph[i][j];</span><br><span class="line">    <span class="keyword">int</span> x,y;<span class="comment">//判断x点和y点是否连通</span></span><br><span class="line">    cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    vis[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(x,y);</span><br><span class="line">    <span class="keyword">if</span>(ans==<span class="number">0</span>)cout&lt;&lt;<span class="string">&quot;不连通&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;连通&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;851-2021&quot;&gt;&lt;a href=&quot;#851-2021&quot; class=&quot;headerlink&quot; title=&quot;851_2021&quot;&gt;&lt;/a&gt;851_2021&lt;/h2&gt;&lt;h3 id=&quot;1-链表题&quot;&gt;&lt;a href=&quot;#1-链表题&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="datastruct" scheme="https://insistgang.github.io/tags/datastruct/"/>
    
    <category term="algorithm" scheme="https://insistgang.github.io/tags/algorithm/"/>
    
    <category term="真题" scheme="https://insistgang.github.io/tags/%E7%9C%9F%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>20年833</title>
    <link href="https://insistgang.github.io/posts/a224a7ac.html"/>
    <id>https://insistgang.github.io/posts/a224a7ac.html</id>
    <published>2022-09-10T06:30:20.000Z</published>
    <updated>2022-10-04T05:57:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="20年833"><a href="#20年833" class="headerlink" title="20年833"></a>20年833</h2><h3 id="1-给一个带头结点单链表，删除所有值为k的节点"><a href="#1-给一个带头结点单链表，删除所有值为k的节点" class="headerlink" title="1. 给一个带头结点单链表，删除所有值为k的节点"></a>1. 给一个带头结点单链表，删除所有值为k的节点</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">ListNode * <span class="title">removeElements</span><span class="params">(ListNode *head,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    ListNode *p=head;</span><br><span class="line">    ListNode *q;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>)<span class="comment">//用p来遍历链表</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;next-&gt;val==k)&#123;<span class="comment">//p的后一个节点为要删除的结点</span></span><br><span class="line">            q=p-&gt;next;</span><br><span class="line">            p-&gt;next=p-&gt;next-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(q);<span class="comment">//删除值为k的结点，并释放内存</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-建立二叉排序树"><a href="#2-建立二叉排序树" class="headerlink" title="2. 建立二叉排序树"></a>2. 建立二叉排序树</h3><p>给定一个数组{10，18，9，2，20，5，6，15，19，25}，设计一个程序根据本数组建立一颗二叉排序树，输入数据时以-1作为结束。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉排序树的定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> *<span class="title">lchild</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BTNode,*BiTree;</span><br><span class="line"><span class="comment">//插入key到二叉排序树中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BSTInsert</span><span class="params">(BiTree &amp;bt,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(bt==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        bt=(BTNode*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(BTNode));</span><br><span class="line">        bt-&gt;lchild=bt-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">        bt-&gt;key=key;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(key&lt;bt-&gt;key)&#123;</span><br><span class="line">        <span class="built_in">BSTInsert</span>(bt-&gt;lchild,key);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key&gt;bt-&gt;key)&#123;</span><br><span class="line">            <span class="built_in">BSTInsert</span>(bt-&gt;rchild,key);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key==bt-&gt;key)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    BiTree tree=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;x&amp;&amp;x!=<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">BSTInsert</span>(tree,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-快速排序"><a href="#3-快速排序" class="headerlink" title="3. 快速排序"></a>3. 快速排序</h3><p>给定数组{46，79，56，52，38，40，80，31，95，24}。要求：</p><ol><li>写出快速排序的思想</li><li>实现快速排序算法，从键盘输入该数组，对其进行排序</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思想：</span></span><br><span class="line"><span class="comment">快速排序使用分治法策略把一个序列分为较小和较大的两个子序列，然后递归排序两个子序列</span></span><br><span class="line"><span class="comment">1. 挑选基准值：从数列中挑出一个数组，称之为“基准”，一般可以挑选当前区间的第一个元素。</span></span><br><span class="line"><span class="comment">2. 分割：重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆放在基准后面（与基准值相等的数可以到任意一边）。在这个分割结束之后，对基准值的排序已经完成。</span></span><br><span class="line"><span class="comment">3. 递归排序子序列：递归将小于基准值元素的子序列和大于基准值元素的子序列排序。</span></span><br><span class="line"><span class="comment">4. 递归到最底部的判断条件是数列的大小是0或1，此时该数列显然已经有序。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qsort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&gt;=right)<span class="comment">//当left==right时，说明当前区间只有一个值，该干的干完了，不用往下了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> num=arr[left];<span class="comment">//标兵的值</span></span><br><span class="line">    <span class="keyword">int</span> i=left;<span class="comment">//左移动指针</span></span><br><span class="line">    <span class="keyword">int</span> j=right;<span class="comment">//右移动指针</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;<span class="comment">//左右指针相碰撞时，划分操作结束，而相遇时的位置就是下一次划分的界限</span></span><br><span class="line">        <span class="comment">//重点！从右边开始扫</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;j&amp;&amp;arr[j]&gt;=num)j--;<span class="comment">//从右边扫找到第一个小于标兵的点</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;j&amp;&amp;arr[i]&lt;=num)i++;<span class="comment">//从左边扫找到第一个大于标兵的点</span></span><br><span class="line">        <span class="built_in">swap</span>(arr,i,j);   <span class="comment">//交换他们</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(arr,left,j);<span class="comment">//两指针相遇后，就找到了下一次划分的界限，把找到的分界线上的值与标兵换一下</span></span><br><span class="line">    <span class="built_in">qsort</span>(arr,left,j<span class="number">-1</span>);<span class="comment">//分界线左边继续划分</span></span><br><span class="line">    <span class="built_in">qsort</span>(arr,j+<span class="number">1</span>,right);<span class="comment">//分界线右边继续划分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-合法出入栈字符序列"><a href="#4-合法出入栈字符序列" class="headerlink" title="4. 合法出入栈字符序列"></a>4. 合法出入栈字符序列</h3><p>输入一串字符串，如IOIOOOII，长度最长为50，其中I代表入栈操作，O代表出栈操作。试设计一个程序，判断输入的字符串序列是否合法的出入栈操作序列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 栈溢出</span></span><br><span class="line"><span class="comment">2. 空栈弹出</span></span><br><span class="line"><span class="comment">3. 栈不能遗留</span></span><br><span class="line"><span class="comment">本题为2.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLegal</span><span class="params">(<span class="keyword">char</span> str[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i]==<span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">            cnt--;</span><br><span class="line">            <span class="keyword">if</span>(cnt&lt;<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-统计二叉树叶子结点"><a href="#5-统计二叉树叶子结点" class="headerlink" title="5. 统计二叉树叶子结点"></a>5. 统计二叉树叶子结点</h3><p>给一个二叉树写一个函数统计叶子结点个数，函数声明void counterleaf(bitree *t,int &amp;count)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">counterleaf</span><span class="params">(bitree *t,<span class="keyword">int</span> &amp;count)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t-&gt;lchild==<span class="literal">NULL</span> &amp;&amp; t-&gt;rchild==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">if</span>(t-&gt;lchild!=<span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">counterleaf</span>(t-&gt;lchild,count);</span><br><span class="line">    <span class="keyword">if</span>(t-&gt;rchild!=<span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">counterleaf</span>(t-&gt;rchild,count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-最小乘船数问题"><a href="#6-最小乘船数问题" class="headerlink" title="6. 最小乘船数问题"></a>6. 最小乘船数问题</h3><p>进行一次独木舟的旅行活动，独木舟可以在港口租到，并且之间没有区别。一条独木舟上乘客的总重量不能超过独木舟的最大承载量，并且每条船最多只能坐两个乘客。我们要尽量减少这次活动中的花销，所以要找出可以安置所有旅客的最少的独木舟条数。现在请写一个程序，读入独木舟的最大承载量、旅客数目和每位旅客的重量。根据给出的规则，计算要安置所有旅客必须的最少的独木舟条数，并输出结果。 第一行输入最大船载重量和乘客数 。第二行输入乘客的重量。输出为所需要的最少独木舟的条数 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MinBoat</span><span class="params">(<span class="keyword">int</span> people[],<span class="keyword">int</span> n,<span class="keyword">int</span> limit)</span></span>&#123;</span><br><span class="line">    <span class="built_in">Sort</span>(people,n);</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j=n;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(people[i]+people[j]&lt;=limit)<span class="comment">//两个人能坐</span></span><br><span class="line">        &#123;</span><br><span class="line">            i++;j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j--;</span><br><span class="line">        ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-最长公共子序列"><a href="#7-最长公共子序列" class="headerlink" title="7. 最长公共子序列"></a>7. 最长公共子序列</h3><p>小王打枪，给定一个目标序列，如 ccca，子弹的序列为 acbc。打枪的规则如下：按照子弹序列的顺序 射击；子弹打中对应的目标得 1 分，否则无分；允许放空枪。假定： </p><p>（1）都是神枪手，只要射击就一定能打中；</p><p>（2）子弹打中目标，目标就销毁；</p><p>（3）共 26 种目标用 26 个小写字母表示。 </p><p>输入第 1 行是子弹列，第 2 行是目标列，输出为 1 个数字，表示最高分 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设数组A长度为n，数组B长度为m</span></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">char</span> a[Maxn];</span><br><span class="line"><span class="keyword">char</span> b[Maxn];</span><br><span class="line"><span class="keyword">int</span> dp[Maxn][Maxn];<span class="comment">//dp[i][j] 表示a串前i个与b串前j个 这两个串的最长公共子序列的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化 i=0表示a串为空串和b串去匹配，则dp=0，j=0 同理</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            dp[i][j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]==b[j])<span class="comment">//如果 i j匹配，取a b串规模更小的最优值+1</span></span><br><span class="line">            dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);<span class="comment">//否则，a或b缩小规模，取两者更优值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="公共汽车问题"><a href="#公共汽车问题" class="headerlink" title="公共汽车问题"></a>公共汽车问题</h3><p> 假设某条街上每一公里就有一个公共汽车站，并且乘车费如下表： </p><p>公里数 1  2   3    4    5    6  7    8  9  10 </p><p>费用   12  21 31 40 49 58 69 79 90 101 </p><p>而任意一辆汽车行驶不能超过 10 公里。某人想行驶 n 公里，他可以任意次换车，请找到一种乘车方案，使得总费用最小。输入为某人想要行驶的公里数，输出为最小费用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*思路：动态规划问题</span></span><br><span class="line"><span class="comment">    假设我们最终的目的是走dis公里，那么有可能是从dis-1位置做1公里车过来，或者从dis-2位置坐2公里车...或者从dis-10公里坐10公里车过来。对于这十种情况，维护最小值，就是走到dis位置的最优值。</span></span><br><span class="line"><span class="comment">    那么自底向上解决这个问题即可。到1公里dp[1]最优值就是cost[1],到2公里dp[2]的最优值就是从0位置2公里车来或从1位置坐1公里车来，这两种情况维护更小。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Mincost</span><span class="params">(<span class="keyword">int</span> cost[],<span class="keyword">int</span> n,<span class="keyword">int</span> Dis)</span><span class="comment">//给了n个公里数分别的花费，Dis表示要走的距离</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[Maxn];</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Dis;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> Min=inf;<span class="comment">//inf表示很大的数字，赋值dp[i]是要找最小值，所以初试化为比较大的数字 考虑i是从哪里来，从i-1或i-2或i-n 共有n种可能，维护n中情况的最小值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="built_in">min</span>(i,n);j++)<span class="comment">//min(i,n)是因为 如果i&lt;n,则i不可能从i-n来</span></span><br><span class="line">            Min=<span class="built_in">min</span>(Min,dp[i-j]+cost[j]);<span class="comment">//dp[i-j]表示从七点走到i-j的位置的花费，再加上cost[j]就是从起点到i的总花费</span></span><br><span class="line">        dp[i]=Min;<span class="comment">//赋值最优情况给dp[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[Mis];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> Dis;</span><br><span class="line">    <span class="keyword">int</span> cost[Maxn];</span><br><span class="line">    <span class="comment">//如果cost数组需要输入</span></span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cin&gt;&gt;cost[i];</span><br><span class="line">    cin&gt;&gt;Dis;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">Mincost</span>(cost,n,Dis)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;20年833&quot;&gt;&lt;a href=&quot;#20年833&quot; class=&quot;headerlink&quot; title=&quot;20年833&quot;&gt;&lt;/a&gt;20年833&lt;/h2&gt;&lt;h3 id=&quot;1-给一个带头结点单链表，删除所有值为k的节点&quot;&gt;&lt;a href=&quot;#1-给一个带头结点单链表，删</summary>
      
    
    
    
    
    <category term="datastruct" scheme="https://insistgang.github.io/tags/datastruct/"/>
    
    <category term="algorithm" scheme="https://insistgang.github.io/tags/algorithm/"/>
    
    <category term="真题" scheme="https://insistgang.github.io/tags/%E7%9C%9F%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>18-19年833</title>
    <link href="https://insistgang.github.io/posts/56e8b8fd.html"/>
    <id>https://insistgang.github.io/posts/56e8b8fd.html</id>
    <published>2022-09-10T06:30:12.000Z</published>
    <updated>2022-09-16T13:18:59.000Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>16-17年833</title>
    <link href="https://insistgang.github.io/posts/181ef313.html"/>
    <id>https://insistgang.github.io/posts/181ef313.html</id>
    <published>2022-09-10T06:30:01.000Z</published>
    <updated>2022-09-15T13:47:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="16-17年833"><a href="#16-17年833" class="headerlink" title="16-17年833"></a>16-17年833</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;16-17年833&quot;&gt;&lt;a href=&quot;#16-17年833&quot; class=&quot;headerlink&quot; title=&quot;16-17年833&quot;&gt;&lt;/a&gt;16-17年833&lt;/h2&gt;</summary>
      
    
    
    
    
    <category term="datastruct" scheme="https://insistgang.github.io/tags/datastruct/"/>
    
    <category term="algorithm" scheme="https://insistgang.github.io/tags/algorithm/"/>
    
    <category term="真题" scheme="https://insistgang.github.io/tags/%E7%9C%9F%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>22真题</title>
    <link href="https://insistgang.github.io/posts/a37401f9.html"/>
    <id>https://insistgang.github.io/posts/a37401f9.html</id>
    <published>2022-09-06T12:14:25.000Z</published>
    <updated>2022-09-15T13:46:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="22真题"><a href="#22真题" class="headerlink" title="22真题"></a>22真题</h2><h3 id="5-（1）使用C语言给出双链表的数据结构-2-写出删除结点的C语言实现"><a href="#5-（1）使用C语言给出双链表的数据结构-2-写出删除结点的C语言实现" class="headerlink" title="5. （1）使用C语言给出双链表的数据结构(2)写出删除结点的C语言实现"></a>5. （1）使用C语言给出双链表的数据结构(2)写出删除结点的C语言实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deletion_beginning</span><span class="params">(node *head)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">ptr</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;UNDERFLOW\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(head-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        head=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">free</span>(head);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;not delete&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ptr=head;</span><br><span class="line">        head=head-&gt;next;</span><br><span class="line">        head-&gt;prev=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">free</span>(ptr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;not delete&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deletion_last</span><span class="params">(note *head)</span></span>&#123;</span><br><span class="line">    node *ptr;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;UNDERFLOW\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        head=<span class="literal">NULL</span>:</span><br><span class="line">        <span class="built_in">free</span>(head);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;not delete&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deletion_specified</span><span class="params">(node *head)</span></span>&#123;</span><br><span class="line">    node *ptr,*temp;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter the data after which the node is to be delete:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;val);</span><br><span class="line">    ptr=head;</span><br><span class="line">    <span class="keyword">while</span>(ptr-&gt;data!=val)</span><br><span class="line">        ptr=ptr-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(ptr==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can&#x27;t delete\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ptr-&gt;next-&gt;prev=ptr-&gt;prev;</span><br><span class="line">        ptr-&gt;prev=ptr-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(ptr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;not delete&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-对于输入的非负十进制整数，打印输出与其等值的八进制数"><a href="#6-对于输入的非负十进制整数，打印输出与其等值的八进制数" class="headerlink" title="6. 对于输入的非负十进制整数，打印输出与其等值的八进制数"></a>6. 对于输入的非负十进制整数，打印输出与其等值的八进制数</h3><ol><li>用C语言给出栈的存储结构</li><li>基于上述存储结构，给出元素入栈和出栈的C语言实现</li><li>基于前两问，用C语言实现本题目</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Elemtype data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">&#125;SqStack;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(SqStack &amp;S,Elemtype x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==MaxSize<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    S.data[++S.top]=x;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S,Elemtype &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x=S.data[S.top--];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SqStack s;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line">ElemType e;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">InitStack</span>(S))<span class="built_in">printf</span>(<span class="string">&quot;\n 初始化栈成功！\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n请输入想要转换的非负十进制整数(以回车键结束):\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;N);</span><br><span class="line"><span class="keyword">while</span>(N)&#123;</span><br><span class="line">    <span class="built_in">Push</span>(S,N%<span class="number">8</span>);</span><br><span class="line">    N/=<span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n 该数对应的八进制数为：\n&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">StackEmpty</span>(S))&#123;</span><br><span class="line">    <span class="built_in">Pop</span>(S,&amp;e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B-树结点数据结构的C语言定义和查找操作的实现"><a href="#B-树结点数据结构的C语言定义和查找操作的实现" class="headerlink" title="B-树结点数据结构的C语言定义和查找操作的实现"></a>B-树结点数据结构的C语言定义和查找操作的实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BTreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *keys;<span class="comment">//存储关键字的数组</span></span><br><span class="line">    <span class="keyword">int</span> t;<span class="comment">//最小度</span></span><br><span class="line">    BTreeNode **C;</span><br><span class="line">    <span class="keyword">int</span> n;<span class="comment">//记录当前结点包含的关键字个数</span></span><br><span class="line">    <span class="keyword">bool</span> leaf;<span class="comment">//叶子结点的一个标记，如果是叶子结点则为true，否则false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*<span class="function">BTreeNode <span class="title">search</span><span class="params">(BTreeNode *<span class="keyword">this</span>,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="comment">//找到第一个大于等于待查找关键字k的关键字</span></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;<span class="keyword">this</span>.n&amp;&amp;k&gt;<span class="keyword">this</span>.keys[i])</span><br><span class="line">        i++;</span><br><span class="line">    <span class="comment">//如果找到的第一个关键字等于k，返回结点指针</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.keys[i]==k)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">//如果没找到关键字k且当前结点为叶子结点则返回NULL</span></span><br><span class="line">    <span class="keyword">if</span>(leaf==<span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//递归访问恰当的子代</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">search</span>(<span class="keyword">this</span>.C[i],k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;22真题&quot;&gt;&lt;a href=&quot;#22真题&quot; class=&quot;headerlink&quot; title=&quot;22真题&quot;&gt;&lt;/a&gt;22真题&lt;/h2&gt;&lt;h3 id=&quot;5-（1）使用C语言给出双链表的数据结构-2-写出删除结点的C语言实现&quot;&gt;&lt;a href=&quot;#5-（1）使用C语言</summary>
      
    
    
    
    
    <category term="datastruct" scheme="https://insistgang.github.io/tags/datastruct/"/>
    
    <category term="algorithm" scheme="https://insistgang.github.io/tags/algorithm/"/>
    
    <category term="真题" scheme="https://insistgang.github.io/tags/%E7%9C%9F%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>19-20真题</title>
    <link href="https://insistgang.github.io/posts/34f2268f.html"/>
    <id>https://insistgang.github.io/posts/34f2268f.html</id>
    <published>2022-09-06T12:14:16.000Z</published>
    <updated>2022-10-04T07:16:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="19-20真题"><a href="#19-20真题" class="headerlink" title="19-20真题"></a>19-20真题</h2><h3 id="自操作表，指表中元素被find函数访问到，就自动移动到表头，并保持其他元素顺序不变"><a href="#自操作表，指表中元素被find函数访问到，就自动移动到表头，并保持其他元素顺序不变" class="headerlink" title="自操作表，指表中元素被find函数访问到，就自动移动到表头，并保持其他元素顺序不变"></a>自操作表，指表中元素被find函数访问到，就自动移动到表头，并保持其他元素顺序不变</h3><ol><li>用数组存储结构写find功能</li><li>写链表存储结构的find功能</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Find</span><span class="params">(<span class="keyword">char</span> a[],<span class="keyword">int</span> n,<span class="keyword">char</span> e)</span></span>&#123;</span><br><span class="line">    <span class="comment">//n为数组长度，e为要查找的元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]==e)&#123;</span><br><span class="line">            <span class="comment">//找到元素之后</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                a[j+<span class="number">1</span>]=a[j];<span class="comment">//i-1位置之前的所有结点后移</span></span><br><span class="line">            &#125;</span><br><span class="line">            a[<span class="number">0</span>]=e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;<span class="comment">//数据域，保存结点的值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span><span class="comment">//指针域</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Find</span><span class="params">(LNode *L,<span class="keyword">char</span> e)</span></span>&#123;</span><br><span class="line">    LNode *p=L-&gt;next,*q=L;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;p-&gt;data!=e)&#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        q=q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;data==e)&#123;</span><br><span class="line">        q-&gt;next=p-&gt;next;<span class="comment">//删除p</span></span><br><span class="line">        p-&gt;next=L-&gt;next;<span class="comment">//将p移动到头结点</span></span><br><span class="line">        L-&gt;next=p;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;所要查找的结点不存在！！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-只用一个二叉树根节点指针T，用高效率方法，计算"><a href="#2-只用一个二叉树根节点指针T，用高效率方法，计算" class="headerlink" title="2. 只用一个二叉树根节点指针T，用高效率方法，计算"></a>2. 只用一个二叉树根节点指针T，用高效率方法，计算</h3><ol><li>所有结点个数</li><li>所有叶子结点个数</li><li>所有满结点个数/所有满状态结点个数</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">递归函数实现的二叉树遍历算法是很低效的，我们采用线索二叉树算法。Tnorder算法输出的a,b,c为相应的结点个数、叶子结点个数和满状态结点个数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TBTNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="keyword">int</span> ltag,rtag;<span class="comment">//线索标记</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TBTNode</span> *<span class="title">lchild</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TBTNode</span> *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tnorder</span><span class="params">(TBTNode *T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>,c=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(TBTNode *p=<span class="built_in">Frist</span>(T);p!=<span class="literal">NULL</span>;p=<span class="built_in">Next</span>(p))&#123;</span><br><span class="line">        <span class="comment">//遍历中序线索树</span></span><br><span class="line">        a++;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;ltag==<span class="number">1</span>&amp;&amp;p-&gt;rtag==<span class="number">1</span>)</span><br><span class="line">            b++;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;ltag==<span class="number">0</span>&amp;&amp;p-&gt;rtag==<span class="number">0</span>)</span><br><span class="line">            c++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;所有结点个数：&quot;</span>&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;叶子结点个数：&quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;满状态结点个数：&quot;</span>&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TBTNode *<span class="title">Frist</span><span class="params">(TBTNode *p)</span></span>&#123;</span><br><span class="line">    <span class="comment">//求以p为根的中序线索二叉树，中序序列下的第一个结点的算法</span></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;ltag==<span class="number">0</span>)&#123;</span><br><span class="line">        p=p-&gt;lchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TBTNode *<span class="title">Next</span><span class="params">(TBTNode *p)</span></span>&#123;</span><br><span class="line">    <span class="comment">//求中序线索二叉树中结点p在中序下的后继结点的算法</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;rtag==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Frist</span>(p-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> p-&gt;rchild;<span class="comment">//rtag=1,直接返回后继线索</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="简述如何不用递归实现归并排序，并实现过程"><a href="#简述如何不用递归实现归并排序，并实现过程" class="headerlink" title="简述如何不用递归实现归并排序，并实现过程"></a>简述如何不用递归实现归并排序，并实现过程</h3><p><img src="../../images/1.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">将数组中的相邻元素两两配对，用Merge()函数将他们排序，构成n/2组长度为2的排序好的子数组段，然后再将他们合并成长度为4的子数组段，如此继续下去，直至整个数组排好序。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100</span></span><br><span class="line"><span class="keyword">int</span> num[maxn];</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class Type&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(Type a[],Type b[],<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=left;</span><br><span class="line">    <span class="keyword">int</span> j=mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k=left;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;a[j])</span><br><span class="line">            b[k++]=a[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b[k++]=a[j++]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;mid)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> z=j;z&lt;=right;z++)</span><br><span class="line">            b[k++]=a[z];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> z=i;z&lt;=mid;z++)</span><br><span class="line">            b[k++]=a[z];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//合并大小为s的相邻子数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergePass</span><span class="params">(Type x[],Type y[],<span class="keyword">int</span> s,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i+<span class="number">2</span>*s<span class="number">-1</span>&lt;n)&#123;</span><br><span class="line">        <span class="built_in">Merge</span>(x,y,i,i+s<span class="number">-1</span>,i+<span class="number">2</span>*s<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">//合并大小为s的相邻2段子数组</span></span><br><span class="line">        i+=<span class="number">2</span>*s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i+s&lt;n)</span><br><span class="line"><span class="comment">//剩下的元素个数m满足:s&lt;=m&lt;2*s</span></span><br><span class="line">        <span class="built_in">Merge</span>(x,y,i,i+s<span class="number">-1</span>,n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line"><span class="comment">//剩下的元素个数m满足：m&lt;s</span></span><br><span class="line">        <span class="built_in">Merge</span>(x,y,i,i,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class Type&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(Type c[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    Type *d=<span class="keyword">new</span> Type[n];</span><br><span class="line">    <span class="keyword">int</span> s=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(s&lt;n)&#123;</span><br><span class="line">        <span class="built_in">MergePass</span>(c,d,s,n);<span class="comment">//合并到数组d</span></span><br><span class="line">        s+=s;</span><br><span class="line">        <span class="comment">//就像图中有序的两个合并为一个</span></span><br><span class="line">        <span class="built_in">MergePass</span>(d,c,s,n);<span class="comment">//合并到数组c</span></span><br><span class="line">        s+=s;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">delete</span>[] b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            cin&gt;&gt;num[i];</span><br><span class="line">        <span class="built_in">MergeSort</span>(num,n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            cout&lt;&lt;num[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现输入n个0-1000的整数，n属于0-1000输出这些整数及他们的出现次数。输出到文件”out-txt”。输出顺序按照出现次数由大到小，次数相同时，数值小的在前"><a href="#实现输入n个0-1000的整数，n属于0-1000输出这些整数及他们的出现次数。输出到文件”out-txt”。输出顺序按照出现次数由大到小，次数相同时，数值小的在前" class="headerlink" title="实现输入n个0 ~ 1000的整数，n属于0 ~ 1000输出这些整数及他们的出现次数。输出到文件”out.txt”。输出顺序按照出现次数由大到小，次数相同时，数值小的在前"></a>实现输入n个0 ~ 1000的整数，n属于0 ~ 1000输出这些整数及他们的出现次数。输出到文件”out.txt”。输出顺序按照出现次数由大到小，次数相同时，数值小的在前</h3><p>输入</p><p>12</p><p>5 3 3 4 5 6 8 7 9 6 4 3</p><p>输出</p><p>3 3,4 2,5 2，6 2，7 1，8 1,9 1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">E</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;<span class="comment">//数据域，保存结点的值</span></span><br><span class="line">    <span class="keyword">int</span> times;<span class="comment">//统计次数</span></span><br><span class="line">&#125;E;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tongji</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//n代表数组长度 初始化</span></span><br><span class="line">    E arr[<span class="number">1000</span>],m;</span><br><span class="line">    arr[<span class="number">0</span>].data=a[<span class="number">0</span>];</span><br><span class="line">    arr[<span class="number">0</span>].times=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;<span class="comment">//i是原数组下标，j是新数组下标</span></span><br><span class="line">    <span class="keyword">int</span> p=<span class="number">0</span>,q=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">1</span>;s&lt;<span class="number">1000</span>;s++)&#123;</span><br><span class="line">        arr[s].times=<span class="number">-1</span>;<span class="comment">//初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">        j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(a[i]!=arr[j].data&amp;&amp;arr[j].times!=<span class="number">-1</span>) j++;</span><br><span class="line">        <span class="keyword">if</span>(arr[j].times==<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="comment">//无相同元素</span></span><br><span class="line">            arr[j].data=a[i];</span><br><span class="line">            arr[j].times=<span class="number">1</span>;</span><br><span class="line">            p=j,q=j;</span><br><span class="line">            <span class="comment">//调换，次数大的在前面，次数相同的数字小的在前</span></span><br><span class="line">            <span class="keyword">while</span>(arr[p].times&gt;arr[p<span class="number">-1</span>].times&amp;&amp;p&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                m=arr[p];</span><br><span class="line">                arr[p]=arr[p<span class="number">-1</span>];</span><br><span class="line">                arr[p<span class="number">-1</span>]=m;</span><br><span class="line">                p--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(arr[q].times==arr[q<span class="number">-1</span>].times&amp;&amp;arr[q].data&lt;arr[q<span class="number">-1</span>].data&amp;&amp;q&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                m=arr[q];</span><br><span class="line">                arr[q]=arr[q<span class="number">-1</span>];</span><br><span class="line">                arr[q<span class="number">-1</span>]=m;</span><br><span class="line">                q--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//相同元素</span></span><br><span class="line">            arr[j].times++;</span><br><span class="line">            p=j,q=j;</span><br><span class="line">            <span class="comment">//调换，次数大的在前面，次数相同的数字小的在前</span></span><br><span class="line">            <span class="keyword">while</span>(arr[p].times&gt;arr[p<span class="number">-1</span>].times&amp;&amp;p&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                m=arr[p];</span><br><span class="line">                arr[p]=arr[p<span class="number">-1</span>];</span><br><span class="line">                arr[p<span class="number">-1</span>]=m;</span><br><span class="line">                p--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(arr[q].times==arr[q<span class="number">-1</span>].times&amp;&amp;arr[q].data&lt;arr[q<span class="number">-1</span>].data&amp;&amp;q&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                m=arr[q];</span><br><span class="line">                arr[q]=arr[q<span class="number">-1</span>];</span><br><span class="line">                arr[q<span class="number">-1</span>]=m;</span><br><span class="line">                q--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span>(r&lt;j) r=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出到文件</span></span><br><span class="line">    FILE *fp;</span><br><span class="line">    fp=<span class="built_in">fopen</span>(<span class="string">&quot;example.txt&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=r;i++)</span><br><span class="line">        <span class="built_in">fprintf</span>(fp,<span class="string">&quot;%d %d&quot;</span>,arr[i].data,arr[i].times);</span><br><span class="line">    <span class="built_in">fclose</span>(fp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,i;</span><br><span class="line">    <span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>||n&gt;<span class="number">1000</span>)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;输入错误！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;arr[i];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&lt;<span class="number">0</span>||arr[i]&gt;<span class="number">1000</span>)&#123;</span><br><span class="line">                flag=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">            <span class="built_in">tongji</span>(arr,n);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;输入有误！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-堆排序"><a href="#5-堆排序" class="headerlink" title="5. 堆排序"></a>5. 堆排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sift</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;<span class="comment">//在low到high范围内对下标为low的元素进行调整</span></span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    i=low,j=<span class="number">2</span>*i;</span><br><span class="line">    <span class="keyword">int</span> temp=a[low];<span class="comment">//以low为根向下交换temp存储我们要调整的元素值</span></span><br><span class="line">    <span class="keyword">while</span>(j&lt;=high)&#123;<span class="comment">//当孩子结点下标合法</span></span><br><span class="line">        <span class="keyword">if</span>(j&lt;high&amp;&amp;a[j]&lt;a[j+<span class="number">1</span>])j++;<span class="comment">//大顶堆 与较大的孩子进行比较</span></span><br><span class="line">        <span class="keyword">if</span>(temp&lt;a[j])&#123;</span><br><span class="line">            a[i]=a[j];<span class="comment">//把孩子结点上调代替父亲节点的位置</span></span><br><span class="line">            i=j;</span><br><span class="line">            j=<span class="number">2</span>*i;<span class="comment">//依次向下进行比较和调整，把较大值孩子结点的下标赋值给i，j指向较大值孩子结点的孩子结点下标。</span></span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    a[i]=temp;<span class="comment">//插入</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n/<span class="number">2</span>;i&gt;<span class="number">0</span>;i--)<span class="built_in">sift</span>(a,i,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">2</span>;i--)&#123;</span><br><span class="line">        temp=a[<span class="number">1</span>];<span class="comment">//每次和最大值交换</span></span><br><span class="line">        a[<span class="number">1</span>]=a[i];</span><br><span class="line">        a[i]=temp;</span><br><span class="line">        <span class="built_in">sift</span>(a,<span class="number">1</span>,i<span class="number">-1</span>);<span class="comment">//只需要调整一次就好</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;19-20真题&quot;&gt;&lt;a href=&quot;#19-20真题&quot; class=&quot;headerlink&quot; title=&quot;19-20真题&quot;&gt;&lt;/a&gt;19-20真题&lt;/h2&gt;&lt;h3 id=&quot;自操作表，指表中元素被find函数访问到，就自动移动到表头，并保持其他元素顺序不变&quot;&gt;&lt;a</summary>
      
    
    
    
    
    <category term="datastruct" scheme="https://insistgang.github.io/tags/datastruct/"/>
    
    <category term="algorithm" scheme="https://insistgang.github.io/tags/algorithm/"/>
    
    <category term="真题" scheme="https://insistgang.github.io/tags/%E7%9C%9F%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>16-18真题</title>
    <link href="https://insistgang.github.io/posts/78993486.html"/>
    <id>https://insistgang.github.io/posts/78993486.html</id>
    <published>2022-09-06T12:14:06.000Z</published>
    <updated>2022-10-04T03:18:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="16-18真题"><a href="#16-18真题" class="headerlink" title="16-18真题"></a>16-18真题</h2><h3 id="1-循环双链表，结点previous-data-next和访问频度域freq-初试为0，每当链表进行一次Locate-L-x-运算时，令x结点freq域的值加1，并使其链表结点频度按递减顺序排序，并实现Locate-L-x-。"><a href="#1-循环双链表，结点previous-data-next和访问频度域freq-初试为0，每当链表进行一次Locate-L-x-运算时，令x结点freq域的值加1，并使其链表结点频度按递减顺序排序，并实现Locate-L-x-。" class="headerlink" title="1. 循环双链表，结点previous,data,next和访问频度域freq,初试为0，每当链表进行一次Locate(L,x)运算时，令x结点freq域的值加1，并使其链表结点频度按递减顺序排序，并实现Locate(L,x)。"></a>1. 循环双链表，结点previous,data,next和访问频度域freq,初试为0，每当链表进行一次Locate(L,x)运算时，令x结点freq域的值加1，并使其链表结点频度按递减顺序排序，并实现Locate(L,x)。</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 找到指定结点 2. 访问频度+1 3. 进行排序</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">int</span> freq;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line">DNode *h;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(DNode *h)</span></span>&#123;<span class="comment">//根据freq降序排列，写成一个函数</span></span><br><span class="line">    DNode *p,*q,*pre;</span><br><span class="line">    p=h-&gt;next-&gt;next;<span class="comment">//指向第二个结点</span></span><br><span class="line">    h-&gt;next-&gt;next=<span class="literal">NULL</span>;<span class="comment">//隔开第一个结点和第二个结点</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        q=p-&gt;next;</span><br><span class="line">        pre=h;</span><br><span class="line">        <span class="comment">//根据freq降序</span></span><br><span class="line">        <span class="keyword">while</span>(pre-&gt;next!=<span class="literal">NULL</span>&amp;&amp;(pre-&gt;next-&gt;freq)&gt;(p-&gt;freq))</span><br><span class="line">            pre=pre-&gt;next;</span><br><span class="line">        p-&gt;next=pre-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(pre-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            pre-&gt;next-&gt;prior=p;</span><br><span class="line">        &#125;</span><br><span class="line">        pre-&gt;next=p;</span><br><span class="line">        p-&gt;prior=pre;</span><br><span class="line">        p=q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LocateNode</span><span class="params">(DNode *h,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    DNode *p;</span><br><span class="line">    p=h-&gt;next;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//查找x所在位置</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;p-&gt;data!=x)&#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;freq++;<span class="comment">//x元素的freq++</span></span><br><span class="line">    <span class="comment">//sort(h);//下面是sort</span></span><br><span class="line">    DNode *q,*pre;</span><br><span class="line">    p=h-&gt;next-&gt;next;</span><br><span class="line">    h-&gt;next-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        q=p-&gt;next;</span><br><span class="line">        pre=h;</span><br><span class="line">        <span class="comment">//根据freq降序</span></span><br><span class="line">        <span class="keyword">while</span>(pre-&gt;next!=<span class="literal">NULL</span>&amp;&amp;(pre-&gt;next-&gt;freq)&gt;(p-&gt;freq))</span><br><span class="line">            pre=pre-&gt;next;</span><br><span class="line">        p-&gt;next=pre-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(pre-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            pre-&gt;next-&gt;prior=p;</span><br><span class="line">        &#125;</span><br><span class="line">        pre-&gt;next=p;</span><br><span class="line">        p-&gt;prior=pre;<span class="comment">//双链表需要链接四个指针</span></span><br><span class="line">        p=q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-X和Y是用结点大小为1的单链表表示的串，请设计算法找出X中第一个不在Y中出现的字符"><a href="#2-X和Y是用结点大小为1的单链表表示的串，请设计算法找出X中第一个不在Y中出现的字符" class="headerlink" title="2. X和Y是用结点大小为1的单链表表示的串，请设计算法找出X中第一个不在Y中出现的字符"></a>2. X和Y是用结点大小为1的单链表表示的串，请设计算法找出X中第一个不在Y中出现的字符</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//X(1-n)：Y(对于X中的每一个结点遍历Y中的所有结点)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(LinkList L1,LinkList L2)</span></span>&#123;</span><br><span class="line">    LinkList p,q;</span><br><span class="line">    p=L1-&gt;next;</span><br><span class="line">    q=L2-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data==q-&gt;data)&#123;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            q=L2-&gt;next;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            q=q-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;x中的字符全部在y中出现过&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(q==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;x中第一个不在Y中出现的字符为：&quot;</span>&lt;&lt;endl;</span><br><span class="line">            cout&lt;&lt;p-&gt;data&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-试编写算法以单链表存储结构实现直接选择排序"><a href="#3-试编写算法以单链表存储结构实现直接选择排序" class="headerlink" title="3. 试编写算法以单链表存储结构实现直接选择排序"></a>3. 试编写算法以单链表存储结构实现直接选择排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//n个数据，排n-1次,每次选择待排序列中最小值交换到待排序列中的第一位置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListChooseSort</span><span class="params">(LNode *head)</span></span>&#123;</span><br><span class="line">    <span class="comment">//用选择法进行排序</span></span><br><span class="line">    LNode *p,*q;</span><br><span class="line">    LNode *temp;</span><br><span class="line">    <span class="keyword">for</span>(p=head-&gt;next;p-&gt;next;p=p-&gt;next)&#123;<span class="comment">//从第一个结点开始，到倒数第二个结点结束</span></span><br><span class="line">        temp=p;</span><br><span class="line">        <span class="keyword">for</span>(q=p-&gt;next;q;q=q-&gt;next)&#123;<span class="comment">//从p的下一个结点开始，到倒数第二个结点结束</span></span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;data&gt;q-&gt;data)</span><br><span class="line">                temp=q;<span class="comment">//选择q</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(p-&gt;data,temp-&gt;data);<span class="comment">//把待排序列中最小值交换到p结点的数据域</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Rand为-0-1-均匀随机产生数"><a href="#4-Rand为-0-1-均匀随机产生数" class="headerlink" title="4. Rand为[0,1]均匀随机产生数"></a>4. Rand为[0,1]均匀随机产生数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)</span><br><span class="line">        a[i]=<span class="built_in">rand</span>()*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d,&quot;</span>,a[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1.</span> <span class="built_in">rand</span>()不需要参数，它会返回一个从<span class="number">0</span>到最大随机数的任意整数，最大随机数的大小通常是固定的一个大整数</span><br><span class="line"><span class="number">2.</span> <span class="number">0</span>~<span class="number">99</span>这<span class="number">100</span>个整数中的一个随机数，可以表达为:<span class="keyword">int</span> num=<span class="built_in">rand</span>()%<span class="number">100</span>;</span><br><span class="line"><span class="number">3.</span> 产生<span class="number">1</span>~<span class="number">100</span>，表达为:<span class="keyword">int</span> num=<span class="built_in">rand</span>()%<span class="number">100</span>+<span class="number">1</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-二分法实现快速幂"><a href="#5-二分法实现快速幂" class="headerlink" title="5. 二分法实现快速幂"></a>5. 二分法实现快速幂</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">fun</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)<span class="comment">//递归结束条件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">double</span> half;</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">1</span>)&#123;<span class="comment">//递归转移方程</span></span><br><span class="line">        half=<span class="built_in">fun</span>(x,n/<span class="number">2</span>);<span class="comment">//x的n/2次方</span></span><br><span class="line">        <span class="keyword">return</span> x*half*half;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        half=<span class="built_in">fun</span>(x,n/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> half*half;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">pow</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> result=<span class="built_in">fun</span>(x,n);</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>)</span><br><span class="line">        result=<span class="number">1</span>/result;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">            n=n<span class="number">-1</span>;</span><br><span class="line">            t*=x;</span><br><span class="line">        &#125;</span><br><span class="line">        x*=x;</span><br><span class="line">        n/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-实现一个栈Stack，要求实现Push-入栈-，Pop（出栈），Min的时间复杂度为O-1"><a href="#6-实现一个栈Stack，要求实现Push-入栈-，Pop（出栈），Min的时间复杂度为O-1" class="headerlink" title="6. 实现一个栈Stack，要求实现Push(入栈)，Pop（出栈），Min的时间复杂度为O(1)"></a>6. 实现一个栈Stack，要求实现Push(入栈)，Pop（出栈），Min的时间复杂度为O(1)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用两个栈_data和_min，_min作为辅助栈。元素value入栈时，将value和_min栈顶元素做比较，如果value小于等于_min.top()，将value分别push到_data和_min，否则value只push到_data中，元素出栈时_data和_min都执行pop操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">stack&lt;<span class="keyword">int</span>&gt; _data,_min;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="comment">//把新元素添加到辅助栈</span></span><br><span class="line">    _data.<span class="built_in">push</span>(value);</span><br><span class="line">    <span class="comment">//当新元素比之前的最小元素小时，把新元素插入到辅助栈里</span></span><br><span class="line">    <span class="comment">//否则把之前的最小元素重复插入辅助栈里</span></span><br><span class="line">    <span class="keyword">if</span>(_min.<span class="built_in">size</span>() == <span class="number">0</span> || value &lt; min.<span class="built_in">top</span>())</span><br><span class="line">        _min.<span class="built_in">push</span>(value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        _min.<span class="built_in">push</span>(_min.<span class="built_in">top</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(_data.<span class="built_in">size</span>()&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    _data.<span class="built_in">pop</span>();</span><br><span class="line">    _min.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Min</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">min_empty</span>())</span><br><span class="line">        <span class="keyword">return</span> _min.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-用二叉树的存储结构将一棵二叉树变成二叉排序树"><a href="#7-用二叉树的存储结构将一棵二叉树变成二叉排序树" class="headerlink" title="7. 用二叉树的存储结构将一棵二叉树变成二叉排序树"></a>7. 用二叉树的存储结构将一棵二叉树变成二叉排序树</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先遍历一遍二叉树获得所有结点值，再依次插入二叉排序中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BTSInsert</span><span class="params">(BTNode *p,<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        p=(BTNode*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(BTNode));</span><br><span class="line">        p-&gt;lchild=p-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;data=data;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data==p-&gt;data)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(data&lt;p-&gt;data)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">BTSInsert</span>(p-&gt;lchild,data);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">BTSInsert</span>(p-&gt;rchild,data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-有两个n维向量相乘，求其点乘的最小值"><a href="#8-有两个n维向量相乘，求其点乘的最小值" class="headerlink" title="8. 有两个n维向量相乘，求其点乘的最小值"></a>8. 有两个n维向量相乘，求其点乘的最小值</h3><p>两个n维的向量，向量的点乘是指向量对应维度的乘积相加，但是我们可以将向量维度交换下可以得到更小的向量点乘，例如三维向量【1,3,-5】和【4,-2,-1】，最小向量点乘为27，即将维度变为【3,1,-5】和【-2,-1,4】<br>只要把第一个向量进行全排列，就可以得到所有的乘积<br>程序设计要求：输入一个整数n为向量的维度，然后输入两个n维度的向量，用空格区别向量元素，输出为一行，包含一个整数，为最小的点乘</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 进行全排列:三行代码 交换 进入下一层 再交换</span></span><br><span class="line"><span class="comment">2. 当排列好之后进行点乘，当结果小于当前最小值时候进行更新</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxnn=<span class="number">1e9</span>+<span class="number">1</span>;<span class="comment">//数值的最大值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn=<span class="number">1e2</span>+<span class="number">1</span>;<span class="comment">//数组的最大值</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> ans=Maxnn;</span><br><span class="line"><span class="keyword">int</span> a[Maxn],b[Maxn];</span><br><span class="line"><span class="keyword">int</span> sum;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t&gt;n)&#123;</span><br><span class="line">        sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            sum+=a[i]*b[i];</span><br><span class="line">        <span class="keyword">if</span>(sum&lt;ans)</span><br><span class="line">            ans=sum;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=t;i&lt;=n;i++)<span class="comment">//从第t个元素交换到第n的元素</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(a[t],a[i]);</span><br><span class="line">            <span class="built_in">backtrack</span>(t+<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">swap</span>(a[t],a[i]);<span class="comment">//回溯，使得a[t]的值不变</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;b[i];</span><br><span class="line">    <span class="built_in">backtrack</span>(<span class="number">1</span>);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-给出五位任意字母或者数组，输出他们排列组合所得到的的所有的合法序列。合法序列是指字符串包含元音字母，且元音字母前后都必须是辅音字母。元音字母为-aeiou"><a href="#9-给出五位任意字母或者数组，输出他们排列组合所得到的的所有的合法序列。合法序列是指字符串包含元音字母，且元音字母前后都必须是辅音字母。元音字母为-aeiou" class="headerlink" title="9. 给出五位任意字母或者数组，输出他们排列组合所得到的的所有的合法序列。合法序列是指字符串包含元音字母，且元音字母前后都必须是辅音字母。元音字母为:aeiou"></a>9. 给出五位任意字母或者数组，输出他们排列组合所得到的的所有的合法序列。合法序列是指字符串包含元音字母，且元音字母前后都必须是辅音字母。元音字母为:aeiou</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 有元音字母2. 0,4不能为元音 3. 不能有两个元音相邻的情况</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span> *s,<span class="keyword">int</span> i,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n&gt;i)&#123;</span><br><span class="line">        temp=s[i];</span><br><span class="line">        s[i]=s[n];</span><br><span class="line">        s[n]=temp;</span><br><span class="line">        i++;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用来判断是否可以打印，0不能打印，1可以打印</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPrint</span><span class="params">(<span class="keyword">char</span> *perm,<span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> first=perm[<span class="number">0</span>];<span class="comment">//0</span></span><br><span class="line">    <span class="keyword">char</span> end=perm[to];<span class="comment">//4</span></span><br><span class="line">    <span class="keyword">if</span>(first==<span class="string">&#x27;a&#x27;</span>||first==<span class="string">&#x27;e&#x27;</span>||first==<span class="string">&#x27;i&#x27;</span>||first==<span class="string">&#x27;o&#x27;</span>||first==<span class="string">&#x27;u&#x27;</span>||end==<span class="string">&#x27;a&#x27;</span>||end==<span class="string">&#x27;e&#x27;</span>||end==<span class="string">&#x27;i&#x27;</span>||end==<span class="string">&#x27;o&#x27;</span>||end==<span class="string">&#x27;u&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">0</span>;<span class="comment">//对一个元素都标记一次</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=to;i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> tmp=perm[i];</span><br><span class="line">        <span class="keyword">if</span>(tmp==<span class="string">&#x27;a&#x27;</span>||tmp==<span class="string">&#x27;e&#x27;</span>||tmp==<span class="string">&#x27;i&#x27;</span>||tmp==<span class="string">&#x27;o&#x27;</span>||tmp==<span class="string">&#x27;u&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag==<span class="number">1</span>)&#123;<span class="comment">//前面一个元素是原因</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                flag=<span class="number">1</span>;<span class="comment">//表明这个元素是元音</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            flag=<span class="number">0</span>;<span class="comment">//表明这个元素是辅音</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=to;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(perm==<span class="string">&#x27;a&#x27;</span>||perm==<span class="string">&#x27;e&#x27;</span>||perm==<span class="string">&#x27;i&#x27;</span>||perm==<span class="string">&#x27;o&#x27;</span>||perm==<span class="string">&#x27;u&#x27;</span>)</span><br><span class="line">            sum++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum&lt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CalAllPer</span><span class="params">(<span class="keyword">char</span> *perm,<span class="keyword">int</span> from,<span class="keyword">int</span> to)</span><span class="comment">//from:0 to:4</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(to &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(from == to)&#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="built_in">IsPrint</span>(perm,to);</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;to;i++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,perm[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=from;j&lt;to;j++)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(perm[j],perm[from]);</span><br><span class="line">            <span class="built_in">CalAllPer</span>(perm,from+<span class="number">1</span>,to);<span class="comment">//递归</span></span><br><span class="line">            <span class="built_in">swap</span>(perm[j],perm[from]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[]=<span class="string">&quot;abelc&quot;</span>;</span><br><span class="line">    <span class="built_in">CalAllPer</span>(a,<span class="number">0</span>,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;16-18真题&quot;&gt;&lt;a href=&quot;#16-18真题&quot; class=&quot;headerlink&quot; title=&quot;16-18真题&quot;&gt;&lt;/a&gt;16-18真题&lt;/h2&gt;&lt;h3 id=&quot;1-循环双链表，结点previous-data-next和访问频度域freq-初试为0，每</summary>
      
    
    
    
    
    <category term="datastruct" scheme="https://insistgang.github.io/tags/datastruct/"/>
    
    <category term="algorithm" scheme="https://insistgang.github.io/tags/algorithm/"/>
    
    <category term="真题" scheme="https://insistgang.github.io/tags/%E7%9C%9F%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>12-15真题</title>
    <link href="https://insistgang.github.io/posts/10a5f53c.html"/>
    <id>https://insistgang.github.io/posts/10a5f53c.html</id>
    <published>2022-09-06T12:13:49.000Z</published>
    <updated>2022-11-10T11:44:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="12-15真题"><a href="#12-15真题" class="headerlink" title="12-15真题"></a>12-15真题</h2><h3 id="求数列1-1-2-1-3-1-4-…1-n"><a href="#求数列1-1-2-1-3-1-4-…1-n" class="headerlink" title="求数列1-1/2+1/3-1/4+…1/n"></a>求数列1-1/2+1/3-1/4+…1/n</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 输入n，即为终止数列的数字</span></span><br><span class="line"><span class="comment">2. 循环判定数字，分母为奇数时，系数为正，分母为偶数时，系数为负</span></span><br><span class="line"><span class="comment">3. 最后在循环的过程中执行数字的累加，最后输出结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">double</span> total;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">double</span> flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            flag=<span class="number">1.0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            flag=<span class="number">-1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        total+=(flag)/(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;total is&quot;</span>&lt;&lt;total&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="输入字符串以！结束，小写转大写，存到text-txt文件中"><a href="#输入字符串以！结束，小写转大写，存到text-txt文件中" class="headerlink" title="输入字符串以！结束，小写转大写，存到text.txt文件中"></a>输入字符串以！结束，小写转大写，存到text.txt文件中</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 利用while循环输入字符串，以！结束，利用len记录字符长度</span></span><br><span class="line"><span class="comment">2. 循环将小写字符转化成大写字符</span></span><br><span class="line"><span class="comment">3. 将字符串写入文件，然后关闭文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line">    FILE *p;</span><br><span class="line">    <span class="keyword">int</span> i,len=<span class="number">0</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入一串英文字符&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">while</span>((str[len]=<span class="built_in">getchar</span>())!=<span class="string">&#x27;!&#x27;</span>)&#123;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        <span class="keyword">if</span>(str[i]&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;str[i]&lt;<span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">            str[i]-=<span class="number">32</span>;</span><br><span class="line">    p=<span class="built_in">fopen</span>(<span class="string">&quot;text.txt&quot;</span>,<span class="string">&quot;a+&quot;</span>);</span><br><span class="line">    <span class="built_in">fputs</span>(str,p);</span><br><span class="line">    <span class="built_in">fclose</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="输入某年某月某日，判断这一天是这一年的第几天"><a href="#输入某年某月某日，判断这一天是这一年的第几天" class="headerlink" title="输入某年某月某日，判断这一天是这一年的第几天"></a>输入某年某月某日，判断这一天是这一年的第几天</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 输入年月日</span></span><br><span class="line"><span class="comment">2. 判断月份，用switch来判定添加的月份包含的日期</span></span><br><span class="line"><span class="comment">3. 如果月份超过2月，2月按28天来算，再加上当月的天数</span></span><br><span class="line"><span class="comment">4. 最后判定是否为闰年，如果是闰年且月份超过2月再加一天，输出总天数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> year,month,day,sum,leap;</span><br><span class="line">    cin&gt;&gt;year&gt;&gt;month&gt;&gt;day;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span>(month)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:sum=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:sum=<span class="number">31</span>;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:sum=<span class="number">59</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:sum=<span class="number">90</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:sum=<span class="number">120</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:sum=<span class="number">151</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:sum=<span class="number">181</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:sum=<span class="number">212</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>:sum=<span class="number">243</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>:sum=<span class="number">273</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">11</span>:sum=<span class="number">304</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">12</span>:sum=<span class="number">334</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:cout&lt;&lt;<span class="string">&quot;data error&quot;</span>&lt;&lt;endl;<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sum+=day;</span><br><span class="line">    <span class="keyword">if</span>(year%<span class="number">400</span>==<span class="number">0</span>||year%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;year%<span class="number">100</span>!=<span class="number">0</span>)</span><br><span class="line">        leap=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        leap=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(leap&amp;&amp;month&gt;<span class="number">2</span>)sum++;</span><br><span class="line">    cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="将文件a和b中的两个字符串交叉合并成为一个字符串，并写入c"><a href="#将文件a和b中的两个字符串交叉合并成为一个字符串，并写入c" class="headerlink" title="将文件a和b中的两个字符串交叉合并成为一个字符串，并写入c"></a>将文件a和b中的两个字符串交叉合并成为一个字符串，并写入c</h3><p>列：”aaaaa”和”bbb”合并结果为”abababaa”，”bbb”和”aaaaa”合并结果为”bababaaaa”</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 将文件a和文件b的内容分别用两个不同的文件指针fp和fq来打开</span></span><br><span class="line"><span class="comment">2. 将文件c用fr来打开</span></span><br><span class="line"><span class="comment">3. 循环读取fp和fq的字符交叉存放到fr中</span></span><br><span class="line"><span class="comment">4. 最后将fr的内容从头到尾写道fp中，然后将关闭文件程序结束</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FILE *fp,*fq,*fc;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">if</span>((fp=<span class="built_in">fopen</span>(<span class="string">&quot;a.txt&quot;</span>,<span class="string">&quot;r&quot;</span>))==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;can&#x27;t open file a.txt&quot;</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((fp=<span class="built_in">fopen</span>(<span class="string">&quot;b.txt&quot;</span>,<span class="string">&quot;r&quot;</span>))==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;can&#x27;t open file b.txt&quot;</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fr=<span class="built_in">fopen</span>(<span class="string">&quot;c.txt&quot;</span>,<span class="string">&quot;a+&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">feof</span>(fp))<span class="comment">//先输入a文件内容，再输入b文件内容</span></span><br><span class="line">    &#123;</span><br><span class="line">        ch=<span class="built_in">fgetc</span>(fp);</span><br><span class="line">        <span class="built_in">fputc</span>(ch,fr);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">feof</span>(fq))&#123;</span><br><span class="line">            ch=<span class="built_in">fgetc</span>(fq);</span><br><span class="line">            <span class="built_in">fputc</span>(ch,fr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">feof</span>(fq))&#123;</span><br><span class="line">        ch=<span class="built_in">fgetc</span>(fq);</span><br><span class="line">        <span class="built_in">fputc</span>(ch,fr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fclose</span>(fp);</span><br><span class="line">    <span class="built_in">fclose</span>(fq);</span><br><span class="line">    <span class="built_in">fclose</span>(fr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现student类对学号姓名三门课的成绩进行管理"><a href="#实现student类对学号姓名三门课的成绩进行管理" class="headerlink" title="实现student类对学号姓名三门课的成绩进行管理"></a>实现student类对学号姓名三门课的成绩进行管理</h3><ol><li>单独设置获取三门课的成绩</li><li>可以计算平均成绩</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 写input函数，输入学生的信息，循环读取三个学生的姓名成绩</span></span><br><span class="line"><span class="comment">2. 写avg函数，根据每名学生的三门课的成绩信息，来计算这位学生的平均成绩</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> num[<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">float</span> score[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">float</span> aver;</span><br><span class="line">&#125;stu[<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">(student stu[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;please enter the information of student&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%s%f%f%f&quot;</span>,&amp;stu[i].num,&amp;stu[i].name,&amp;stu[i].score[<span class="number">0</span>],&amp;stu[i].score[<span class="number">1</span>],&amp;stu[i].score[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">avg</span><span class="params">(struct student stu[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">float</span> sum,aver;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;</span><br><span class="line">        sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">            sum+=(stu[j].score[i]);</span><br><span class="line">       aver=sum/<span class="number">3.0</span>;</span><br><span class="line">        stu[i].aver=aver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">input</span>(student stu[]);</span><br><span class="line">    <span class="built_in">avg</span>(student stu[]);</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++) <span class="built_in">printf</span>(<span class="string">&quot;%s%s%f%f%f%f&quot;</span>,stu[i].num,stu[i].name,stu[i].score[<span class="number">0</span>],stu[i].score[<span class="number">1</span>],stu[i].score[<span class="number">2</span>],stu[i].aver);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输入n组等长字符串，用指针的方法进行冒泡排序，在函数中实现"><a href="#输入n组等长字符串，用指针的方法进行冒泡排序，在函数中实现" class="headerlink" title="输入n组等长字符串，用指针的方法进行冒泡排序，在函数中实现"></a>输入n组等长字符串，用指针的方法进行冒泡排序，在函数中实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 写冒泡排序，用字符串比较来交换的方法来进行排序</span></span><br><span class="line"><span class="comment">2. 利用指针数组p来存放输入的数组</span></span><br><span class="line"><span class="comment">3. p和字符的组数n传参排序，最后输出</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">char</span> *str[],<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">char</span> *temp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;size<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;size-i<span class="number">-1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strcmp</span>(str[j],str[j+<span class="number">1</span>])&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                temp=str[j];</span><br><span class="line">                str[j]=str[j+<span class="number">1</span>];</span><br><span class="line">                str[j+<span class="number">1</span>]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p[<span class="number">200</span>],str[<span class="number">200</span>][<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> i,n;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入字符串的个数：&quot;</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;str[i];</span><br><span class="line">        p[i]=str[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(p,n);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;排序后的结果:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cout&lt;&lt;p[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="输入一组字符倒序输出，输出结果保存到out-txt"><a href="#输入一组字符倒序输出，输出结果保存到out-txt" class="headerlink" title="输入一组字符倒序输出，输出结果保存到out.txt"></a>输入一组字符倒序输出，输出结果保存到out.txt</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">string</span><span class="params">(<span class="keyword">char</span> *str,FILE *fp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(*str==<span class="string">&#x27;\0&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">string</span>(str+<span class="number">1</span>,fp);</span><br><span class="line">        <span class="built_in">fputc</span>(*str,fp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">char</span> *ch;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">if</span>(fp=<span class="built_in">fopen</span>(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w+&quot;</span>)==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;cannot open file&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;input a string:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">    ch=str;</span><br><span class="line">    <span class="built_in">string</span>(ch,fp);</span><br><span class="line">    <span class="built_in">fclose</span>(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="黑色星期五，每个月中十三号是星期五称为黑色星期五"><a href="#黑色星期五，每个月中十三号是星期五称为黑色星期五" class="headerlink" title="黑色星期五，每个月中十三号是星期五称为黑色星期五"></a>黑色星期五，每个月中十三号是星期五称为黑色星期五</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1900年1月1日星期一</span></span><br><span class="line"><span class="comment">总天数=该年之前的年份总天数+该年1月1日到该月1日为止的天数+该月1日到该日的天数</span></span><br><span class="line"><span class="comment">1. 完成三个函数，第一个返回平年每月的天数，第二个返回闰年每月的天数，第三个判断闰年还是平年</span></span><br><span class="line"><span class="comment">2. 从1900年1月1日开始往后加，求总天数，先加到前一年通过是否是闰年判断总天数</span></span><br><span class="line"><span class="comment">3. 根据返回的月份来累加天数，在根据日加到最后的天数13即为总天数</span></span><br><span class="line"><span class="comment">4. 总天数取余数结果为5即为黑色星期五</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">run</span><span class="params">(<span class="keyword">int</span> year)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(year%<span class="number">400</span>==<span class="number">0</span>||year%<span class="number">100</span>!=<span class="number">0</span>&amp;&amp;year%<span class="number">4</span>==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">13</span>]=&#123;<span class="number">0</span>,<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1900</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">run</span>(i)==<span class="number">1</span>)</span><br><span class="line">            sum+=<span class="number">366</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            sum+=<span class="number">365</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">run</span>(n)==<span class="number">1</span>)&#123;</span><br><span class="line">        arr[<span class="number">2</span>]=<span class="number">29</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">12</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">run</span>(n)==<span class="number">1</span>)&#123;</span><br><span class="line">            sum=<span class="number">13</span>+sum;</span><br><span class="line">            <span class="keyword">if</span>(sum%<span class="number">7</span>==<span class="number">5</span>)&#123;</span><br><span class="line">                cout&lt;&lt;n&lt;&lt;<span class="string">&quot;年&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;月&quot;</span>&lt;&lt;<span class="string">&quot;13号&quot;</span>&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">            sum=sum<span class="number">-13</span>+arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树以二叉链表存储，证明二叉树是满二叉树"><a href="#二叉树以二叉链表存储，证明二叉树是满二叉树" class="headerlink" title="二叉树以二叉链表存储，证明二叉树是满二叉树"></a>二叉树以二叉链表存储，证明二叉树是满二叉树</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个n层满二叉树总数为2的n次幂-1，利用先序遍历递归</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumtree</span><span class="params">(Bitree *T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)&#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="built_in">sumtree</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">sumtree</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二叉树深度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> u=<span class="built_in">height</span>(T-&gt;lchild);<span class="comment">//统计左子树高度</span></span><br><span class="line">    <span class="keyword">int</span> v=<span class="built_in">height</span>(T-&gt;rchild);<span class="comment">//统计右子树高度</span></span><br><span class="line">    <span class="keyword">if</span>(u&gt;v) <span class="keyword">return</span> u+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> v+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    BiTree *T;</span><br><span class="line">    <span class="built_in">sumtree</span>(T);</span><br><span class="line">    <span class="keyword">int</span> h=<span class="built_in">height</span>(T);</span><br><span class="line">    <span class="keyword">if</span>(i==(<span class="built_in">pow</span>(<span class="number">2</span>,h)<span class="number">-1</span>))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;此二叉树为满二叉树&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;此二叉树不是满二叉树&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉排序树以x为根节点的子树。要求用非递归算法并释放掉该结点。-删除某个结点"><a href="#二叉排序树以x为根节点的子树。要求用非递归算法并释放掉该结点。-删除某个结点" class="headerlink" title="二叉排序树以x为根节点的子树。要求用非递归算法并释放掉该结点。(删除某个结点)"></a>二叉排序树以x为根节点的子树。要求用非递归算法并释放掉该结点。(删除某个结点)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">delete</span><span class="params">(BiTree *p)</span></span>&#123;</span><br><span class="line">    BiTree *q,*s;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;rchild==<span class="literal">NULL</span>)<span class="comment">//右子树空则只需重接它的左子树</span></span><br><span class="line">    &#123;</span><br><span class="line">        p=p-&gt;lchild;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;lchild==<span class="literal">NULL</span>)<span class="comment">//只需要重接它的右子树</span></span><br><span class="line">    &#123;</span><br><span class="line">        p=p-&gt;rchild;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//左右子树均不空</span></span><br><span class="line">        q=p;</span><br><span class="line">        s=p-&gt;lchild;</span><br><span class="line">        <span class="keyword">while</span>(s-&gt;rchild)&#123;<span class="comment">//转左，然后向右走到尽头</span></span><br><span class="line">            q=s;</span><br><span class="line">            s=s-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;data=s-&gt;data;<span class="comment">//s指向被删节点的直接前驱</span></span><br><span class="line">        <span class="keyword">if</span>(q!=p)<span class="comment">//s有右子树</span></span><br><span class="line">            q-&gt;rchild=s-&gt;lchild;<span class="comment">//重新连接q的右子树</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            q-&gt;lchild=s-&gt;lchild;<span class="comment">//重新连接q的左子树</span></span><br><span class="line">        <span class="built_in">free</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="ABCDEF六个变量分别是1-6的整数，且各不相同，组成一个等边三角形，找出三边相等有多少种可能性。即A-B-D-A-C-F-D-E-F"><a href="#ABCDEF六个变量分别是1-6的整数，且各不相同，组成一个等边三角形，找出三边相等有多少种可能性。即A-B-D-A-C-F-D-E-F" class="headerlink" title="ABCDEF六个变量分别是1-6的整数，且各不相同，组成一个等边三角形，找出三边相等有多少种可能性。即A+B+D=A+C+F=D+E+F"></a>ABCDEF六个变量分别是1-6的整数，且各不相同，组成一个等边三角形，找出三边相等有多少种可能性。即A+B+D=A+C+F=D+E+F</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,c,d,e,f;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(a=<span class="number">6</span>;a&gt;=<span class="number">1</span>;a--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(b=<span class="number">6</span>;b&gt;=<span class="number">1</span>;b--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(b!=a)&#123;</span><br><span class="line">                <span class="keyword">for</span>(c=<span class="number">6</span>;c&gt;=<span class="number">1</span>;c--)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(b!=c&amp;&amp;a!=c)&#123;</span><br><span class="line">                        <span class="keyword">for</span>(d=<span class="number">6</span>;d&gt;=<span class="number">1</span>;d--)&#123;</span><br><span class="line">                            <span class="keyword">if</span>(d!=c&amp;&amp;d!=b&amp;&amp;d!=a)&#123;</span><br><span class="line">                                <span class="keyword">for</span>(e=<span class="number">6</span>;e&gt;=<span class="number">1</span>;e--)&#123;</span><br><span class="line">                                    <span class="keyword">if</span>(e!=a&amp;&amp;e!=b&amp;&amp;e!=c&amp;&amp;e!=d)&#123;</span><br><span class="line">                                        <span class="keyword">for</span>(f=<span class="number">6</span>;f&gt;=<span class="number">1</span>;f--)&#123;</span><br><span class="line">                                            <span class="keyword">if</span>(f!=a&amp;&amp;f!=b&amp;&amp;f!=c&amp;&amp;f!=e)&#123;</span><br><span class="line">                                                <span class="keyword">if</span>(a+b+d==a+c+f=d+e+f)</span><br><span class="line">                                                    cnt++;</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;12-15真题&quot;&gt;&lt;a href=&quot;#12-15真题&quot; class=&quot;headerlink&quot; title=&quot;12-15真题&quot;&gt;&lt;/a&gt;12-15真题&lt;/h2&gt;&lt;h3 id=&quot;求数列1-1-2-1-3-1-4-…1-n&quot;&gt;&lt;a href=&quot;#求数列1-1-2-1-3</summary>
      
    
    
    
    
    <category term="datastruct" scheme="https://insistgang.github.io/tags/datastruct/"/>
    
    <category term="algorithm" scheme="https://insistgang.github.io/tags/algorithm/"/>
    
    <category term="真题" scheme="https://insistgang.github.io/tags/%E7%9C%9F%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>专业课数据结构部分合集</title>
    <link href="https://insistgang.github.io/posts/a8b46908.html"/>
    <id>https://insistgang.github.io/posts/a8b46908.html</id>
    <published>2022-08-10T12:08:59.000Z</published>
    <updated>2022-08-10T12:41:40.000Z</updated>
    
    
    
    
    
    <category term="考研" scheme="https://insistgang.github.io/tags/%E8%80%83%E7%A0%94/"/>
    
    <category term="datastruct" scheme="https://insistgang.github.io/tags/datastruct/"/>
    
  </entry>
  
  <entry>
    <title>数据结构测试卷</title>
    <link href="https://insistgang.github.io/posts/5c16dd3e.html"/>
    <id>https://insistgang.github.io/posts/5c16dd3e.html</id>
    <published>2022-08-10T12:08:40.000Z</published>
    <updated>2022-08-10T12:41:31.000Z</updated>
    
    
    
    
    
    <category term="考研" scheme="https://insistgang.github.io/tags/%E8%80%83%E7%A0%94/"/>
    
    <category term="datastruct" scheme="https://insistgang.github.io/tags/datastruct/"/>
    
  </entry>
  
  <entry>
    <title>数据结构第二次习题课</title>
    <link href="https://insistgang.github.io/posts/17be3fca.html"/>
    <id>https://insistgang.github.io/posts/17be3fca.html</id>
    <published>2022-08-10T12:08:01.000Z</published>
    <updated>2022-11-10T10:02:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据结构第二次习题课"><a href="#数据结构第二次习题课" class="headerlink" title="数据结构第二次习题课"></a>数据结构第二次习题课</h2><h3 id="二叉树按二叉链表形式存储"><a href="#二叉树按二叉链表形式存储" class="headerlink" title="二叉树按二叉链表形式存储"></a>二叉树按二叉链表形式存储</h3><ol><li>建立完全二叉树的算法</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BTNode,*BiTree;</span><br><span class="line"><span class="comment">//采用先序遍历构建二叉树</span></span><br><span class="line"><span class="function">BiTree <span class="title">CreateTree</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    BiTree *bt;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>) bt=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        bt=(BiTree)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(BTNode));</span><br><span class="line">        bt-&gt;data=x;</span><br><span class="line">        bt-&gt;lchild=<span class="built_in">CreateTree</span>();</span><br><span class="line">        bt-&gt;rchild=<span class="built_in">CreateTree</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>写一个判断给定的二叉树是否是完全二叉树的算法</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">完全二叉树的结点编号于满二叉树的结点编号一一对应。</span></span><br><span class="line"><span class="comment">采用层序遍历算法，将所有结点加入序列，遇到空结点时，</span></span><br><span class="line"><span class="comment">查看队列中是否还有非空结点，若有则不少二叉树。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CheckTree</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T=<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    BiTree q[Max_Size];</span><br><span class="line">    <span class="keyword">int</span> front=<span class="number">0</span>,rear=<span class="number">0</span>;</span><br><span class="line">    BiTree p=T;</span><br><span class="line">    q[++rear]=p;</span><br><span class="line">    <span class="keyword">while</span>(front&lt;rear)&#123;</span><br><span class="line">        p=q[++front];</span><br><span class="line">        <span class="keyword">if</span>(q!=<span class="literal">NULL</span>)&#123;<span class="comment">//左右孩子入队</span></span><br><span class="line">            q[++rear]=p-&gt;lchild;</span><br><span class="line">            q[++rear]=p-&gt;rchild;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//空指针则出队，若知道队空都是空指针，就为完全二叉树。</span></span><br><span class="line">            <span class="keyword">while</span>(front&lt;rear)&#123;</span><br><span class="line">                p=q[++front];</span><br><span class="line">                <span class="keyword">if</span>(p)<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//空指针后又有结点指针，不是完全二叉树。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="已知先序和中序遍历序列存于两个一维数组，编写算法建立该二叉树的二叉链表"><a href="#已知先序和中序遍历序列存于两个一维数组，编写算法建立该二叉树的二叉链表" class="headerlink" title="已知先序和中序遍历序列存于两个一维数组，编写算法建立该二叉树的二叉链表"></a>已知先序和中序遍历序列存于两个一维数组，编写算法建立该二叉树的二叉链表</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">给定二叉树结点的先序和中序序列，可以唯一确定该二叉树，</span></span><br><span class="line"><span class="comment">因为前序序列的第一个元素是根节点，该元素将二叉树的中序序列分成两部分，</span></span><br><span class="line"><span class="comment">左边（设l个元素）表示左子树，若左边无元素，则说明左子树为空；</span></span><br><span class="line"><span class="comment">右边（设r个元素）表示右子树，若右边无元素，则右子树为空。</span></span><br><span class="line"><span class="comment">根据前序遍历：“根左右”的顺序，则由第二元素开始的l个结点序列构造左子树，</span></span><br><span class="line"><span class="comment">由前序序列最好r个元素序列与中序序列根右边的r个元素序列构造右子树。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BTNode,*BiTree;</span><br><span class="line"><span class="function">BiTree <span class="title">CreateTree</span><span class="params">(<span class="keyword">int</span> pre[],<span class="keyword">int</span> l1,<span class="keyword">int</span> r1,<span class="keyword">int</span> in[],<span class="keyword">int</span> l2,<span class="keyword">int</span> r2)</span></span>&#123;</span><br><span class="line">    BiTree root=(BiTree)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(BTNode));</span><br><span class="line">    root-&gt;data=pre[l1];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=l2;i&lt;=r2;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i]==pre[l1])<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> llen=i-l2;<span class="comment">//左子树长度;</span></span><br><span class="line">    <span class="keyword">int</span> rlen=r2-i;<span class="comment">//右子树长度;</span></span><br><span class="line">    <span class="comment">//递归建立左子树</span></span><br><span class="line">    <span class="keyword">if</span>(llen==<span class="number">0</span>)&#123;</span><br><span class="line">        root-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        root-&gt;lchild=<span class="built_in">CreateTree</span>(pre,l1+<span class="number">1</span>,l1+llen,in,l2,l2+llen<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归建立右子树</span></span><br><span class="line">    <span class="keyword">if</span>(rlen==<span class="number">0</span>)&#123;</span><br><span class="line">        root-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        root-&gt;rchild=<span class="built_in">CreateTree</span>(pre,r1-rlen+<span class="number">1</span>,r1,in,r2-rlen+<span class="number">1</span>,r2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;<span class="comment">//返回根节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="已知中序和后序遍历序列存于两个一维数组，编写算法建立该二叉树的二叉链表"><a href="#已知中序和后序遍历序列存于两个一维数组，编写算法建立该二叉树的二叉链表" class="headerlink" title="已知中序和后序遍历序列存于两个一维数组，编写算法建立该二叉树的二叉链表"></a>已知中序和后序遍历序列存于两个一维数组，编写算法建立该二叉树的二叉链表</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">给定二叉树结点的后序序列和中序序列,可以唯一确定该二叉树。</span></span><br><span class="line"><span class="comment">因为后序序列的第最后一个元素是根结点，该元素将二叉树的中序序列分成两部分，</span></span><br><span class="line"><span class="comment">左边(设l个元素)表示左子树，若左边无元素,则说明左子树为空;右边(设r个元素)是右子树，</span></span><br><span class="line"><span class="comment">若右边无元素,则右子树为空。根据后序遍历中“左子树-右子树-根”的顺序，</span></span><br><span class="line"><span class="comment">则由从第1个元素开始的l个结点序列和中序序列根左边的1个结点序列构造左子树,</span></span><br><span class="line"><span class="comment">由后序序列倒数第二个元素开始的r个结点序列与中序序列根右边的r个元素序列构造右子树。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; BTNode, *BiTree;</span><br><span class="line"><span class="function">BiTree <span class="title">CreateTree</span><span class="params">(<span class="keyword">int</span> post[],<span class="keyword">int</span> l1,<span class="keyword">int</span> r1,<span class="keyword">int</span> in[],<span class="keyword">int</span> l2,intr2)</span></span>&#123;</span><br><span class="line">    BiTree root=(BiTree)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(BTNode));</span><br><span class="line">root-&gt;data=post[r1];</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=l2;i&lt;=r2;i++)&#123;<span class="comment">//在中序序列中查找根节点并将其分成左右子树</span></span><br><span class="line">        <span class="keyword">if</span>(in[i]==post[r1]) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">int</span> llen=i-l2;<span class="comment">//左子树长度</span></span><br><span class="line">    <span class="keyword">int</span> rlen=r2-i;<span class="comment">//右子树长度</span></span><br><span class="line">    <span class="comment">//递归建立左子树</span></span><br><span class="line">    <span class="keyword">if</span>(llen==<span class="number">0</span>)&#123;</span><br><span class="line">root-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">root-&gt;lchild=<span class="built_in">CreateTree</span>(post,l1,l1+llen<span class="number">-1</span>,in,l2,l2+llen<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//递归建立右子树</span></span><br><span class="line"><span class="keyword">if</span>(rlen==<span class="number">0</span>)&#123;</span><br><span class="line">root-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">root-&gt;rchild=<span class="built_in">CreateTree</span>(post,l1+llen,r1<span class="number">-1</span>,in,r2-rlen+<span class="number">1</span>,r2);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> root;<span class="comment">//返回根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="以二叉链表形式存储，求该树第k层的结点数"><a href="#以二叉链表形式存储，求该树第k层的结点数" class="headerlink" title="以二叉链表形式存储，求该树第k层的结点数"></a>以二叉链表形式存储，求该树第k层的结点数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SIZE 105</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BTNode,*BiTree;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">T指当前为根的树</span></span><br><span class="line"><span class="comment">depth指当前结点的深度</span></span><br><span class="line"><span class="comment">count计数处理</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Count_k_Leaf</span><span class="params">(BiTree T,<span class="keyword">int</span> depth,<span class="keyword">int</span> k,<span class="keyword">int</span> &amp;count)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(depth==k) count++;<span class="comment">//当前结点在第k层</span></span><br><span class="line">    <span class="built_in">Count_k_Leaf</span>(T-&gt;lchild,depth+<span class="number">1</span>,k,count);</span><br><span class="line">    <span class="built_in">Count_k_Leaf</span>(T-&gt;rchild,depth+<span class="number">1</span>,k,count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非递归(层序遍历)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Count_k_Leaf</span><span class="params">(BiTree T,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    BiTree q[MAX_SIZE];</span><br><span class="line">    <span class="keyword">int</span> front=<span class="number">0</span>,rear=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> level=<span class="number">0</span>,count;<span class="comment">//分别表示层次值，第k层结点数</span></span><br><span class="line">    BiTree p=T;</span><br><span class="line">    q[++rear]=p;</span><br><span class="line">    <span class="keyword">while</span>(front&lt;rear)&#123;</span><br><span class="line">        level++;<span class="comment">//深度+1</span></span><br><span class="line">        <span class="keyword">if</span>(level==k) cout=rear-front;</span><br><span class="line">        <span class="keyword">int</span> l=front+<span class="number">1</span>,r=rear;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++)&#123;<span class="comment">//对level层结点进行遍历</span></span><br><span class="line">            <span class="keyword">if</span>(q[i]-&gt;lchild!=<span class="literal">NULL</span>) q[++rear]=q[i]-&gt;lchild;</span><br><span class="line">            <span class="keyword">if</span>(q[i]-&gt;rchild!=<span class="literal">NULL</span>) q[++rear]=q[i]-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        front=r;<span class="comment">//更新队列的指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="假定一棵树以二叉链表进行存储，T指向该二叉树的根节点指针，p和q分别指向该二叉树中任意两个节点的指针，试编写算法找到p和q节点的最近公共祖先。"><a href="#假定一棵树以二叉链表进行存储，T指向该二叉树的根节点指针，p和q分别指向该二叉树中任意两个节点的指针，试编写算法找到p和q节点的最近公共祖先。" class="headerlink" title="假定一棵树以二叉链表进行存储，T指向该二叉树的根节点指针，p和q分别指向该二叉树中任意两个节点的指针，试编写算法找到p和q节点的最近公共祖先。"></a>假定一棵树以二叉链表进行存储，T指向该二叉树的根节点指针，p和q分别指向该二叉树中任意两个节点的指针，试编写算法找到p和q节点的最近公共祖先。</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">后续遍历的非递归算法的特性：当访问一个结点p时，栈中结点恰好是p结点的所有祖先</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SIZE 105</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BTNode,*BiTree;</span><br><span class="line"><span class="function">BiTree <span class="title">SearchAncestor</span><span class="params">(BiTree T,BiTree p,BiTree q)</span></span>&#123;</span><br><span class="line">    <span class="comment">//s辅助栈s1存储p结点的祖先s2存储q结点的祖先</span></span><br><span class="line">    BiTree s[MAX_SIZE],s1[MAX_SIZE],s2[MAX_SIZE];</span><br><span class="line">    <span class="keyword">int</span> top=<span class="number">0</span>,top1=<span class="number">0</span>,top2=<span class="number">0</span>;</span><br><span class="line">    BiTree t=T,r=<span class="literal">NULL</span>;<span class="comment">//遍历指针 最近访问过的结点 </span></span><br><span class="line">    <span class="keyword">while</span>(t!=<span class="literal">NULL</span> || top &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(t!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            s[++top]=t;</span><br><span class="line">            t=t-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向右走</span></span><br><span class="line">        t=s[top];<span class="comment">//获取栈顶元素</span></span><br><span class="line">        <span class="keyword">if</span>(t-&gt;rchild &amp;&amp; t-&gt;rchild != r)&#123;<span class="comment">//若右子树存在且未被访问过</span></span><br><span class="line">            t=t-&gt;rchild;<span class="comment">//转向右子树</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//否则，弹出结点并访问</span></span><br><span class="line">            <span class="keyword">if</span>(t==p)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=top;i&gt;<span class="number">0</span>;i--) s1[++top1]=s[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(t==q)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=top;i&gt;<span class="number">0</span>;i--) s2[++top2]=s[i];</span><br><span class="line">            &#125;</span><br><span class="line">            top--;<span class="comment">//栈顶元素出栈</span></span><br><span class="line">            r=t;<span class="comment">//记录最近访问过的结点</span></span><br><span class="line">            t=<span class="literal">NULL</span>;<span class="comment">//结点访问完，重置t指针</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//自顶向下查找最后一个相同结点</span></span><br><span class="line">    <span class="keyword">while</span>(top1&gt;<span class="number">0</span>&amp;&amp;top2&gt;<span class="number">0</span>&amp;&amp;s1[top1]==s2[top2])&#123;</span><br><span class="line">        top1--;top2--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s1[top1<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据结构第二次习题课&quot;&gt;&lt;a href=&quot;#数据结构第二次习题课&quot; class=&quot;headerlink&quot; title=&quot;数据结构第二次习题课&quot;&gt;&lt;/a&gt;数据结构第二次习题课&lt;/h2&gt;&lt;h3 id=&quot;二叉树按二叉链表形式存储&quot;&gt;&lt;a href=&quot;#二叉树按二叉链表形</summary>
      
    
    
    
    
    <category term="考研" scheme="https://insistgang.github.io/tags/%E8%80%83%E7%A0%94/"/>
    
    <category term="datastruct" scheme="https://insistgang.github.io/tags/datastruct/"/>
    
  </entry>
  
  <entry>
    <title>数据结构第一次习题课</title>
    <link href="https://insistgang.github.io/posts/6c6a429c.html"/>
    <id>https://insistgang.github.io/posts/6c6a429c.html</id>
    <published>2022-08-10T12:07:54.000Z</published>
    <updated>2022-09-02T03:17:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一次习题课"><a href="#第一次习题课" class="headerlink" title="第一次习题课"></a>第一次习题课</h2><h3 id="阶乘和"><a href="#阶乘和" class="headerlink" title="阶乘和"></a>阶乘和</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cal=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=x;i++)&#123;</span><br><span class="line">        cal*=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    LNode p=L-&gt;next;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        ans+=<span class="built_in">cal</span>(p-&gt;data);</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>在长度为N的数组arr中，将小于等于arr[0]的数放在数组的左半部分，大于arr[0]的放在右半部分， arr[0]介于中间，输出处理后的数组 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> arr[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> num=arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="comment">//重点！先从右边开始扫</span></span><br><span class="line">        <span class="keyword">while</span>(arr[j]&gt;=num&amp;&amp;i&lt;j)j--;<span class="comment">//从右边扫找到第一个小于标兵的点</span></span><br><span class="line">        <span class="keyword">while</span>(arr[i]&lt;=num&amp;&amp;i&lt;j)i++;<span class="comment">//从左边扫找到第一个大于标兵的点</span></span><br><span class="line">        <span class="built_in">swap</span>(arr[i],arr[j]);<span class="comment">//交换他们</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(arr[j],arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cout&lt;&lt;arr[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表重排"><a href="#链表重排" class="headerlink" title="链表重排"></a>链表重排</h3><p> 有一个长度为n有序的带头结点单链表L={a1,a2…an}，设计一个空间复杂度O(1)，时间上尽可能高效的 算法，重新排列L中的结点，得到线性表L’={a1,an,a2,an-2….}，给出算法设计思想并实现，说明时间复杂度 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(LinkList &amp;L,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    LNode *p;</span><br><span class="line">    p=head-&gt;next;</span><br><span class="line">    LNode *q;</span><br><span class="line">    LNode *r;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i++&lt;n/<span class="number">2</span>)</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    r=p-&gt;next;</span><br><span class="line">    q=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(r)&#123;</span><br><span class="line">        p=r-&gt;next;</span><br><span class="line">        r-&gt;next=q;</span><br><span class="line">        q=r;</span><br><span class="line">        r=p;</span><br><span class="line">    &#125;</span><br><span class="line">    p=head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next&amp;&amp;q-&gt;next)&#123;</span><br><span class="line">        r=p-&gt;next;</span><br><span class="line">        s=q-&gt;next;</span><br><span class="line">        p-&gt;next=q;</span><br><span class="line">        q-&gt;next=r;</span><br><span class="line">        p=r;</span><br><span class="line">        q=s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;next==null)</span><br><span class="line">        p-&gt;next=q;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        q-&gt;next=p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表合并"><a href="#链表合并" class="headerlink" title="链表合并"></a>链表合并</h3><p>求两个递增有序带头结点链表LA和LB的并集，形成的新的链表，假设这两个链表都不含有重复的数字， 求并集指的是LA和LB共有的元素只保留一个 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">fun</span><span class="params">(LinkList &amp;LA,LinkList &amp;LB)</span></span>&#123;</span><br><span class="line">    LNode *p=LA-&gt;next;</span><br><span class="line">    LNode *q=LB-&gt;next;</span><br><span class="line">    LA-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    LNode *r=LA;</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">9999</span>;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;q!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data&lt;=q-&gt;data)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;data!=num)&#123;</span><br><span class="line">                r-&gt;next=p;</span><br><span class="line">                r=r-&gt;next;</span><br><span class="line">                num=p-&gt;data;</span><br><span class="line">            &#125;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(q-&gt;data!=num)&#123;</span><br><span class="line">                r-&gt;next=q;</span><br><span class="line">                r=r-&gt;next;</span><br><span class="line">                num=q-&gt;data;</span><br><span class="line">            &#125;</span><br><span class="line">            q=q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)r-&gt;next=p;</span><br><span class="line">    <span class="keyword">if</span>(q!=<span class="literal">NULL</span>) r-&gt;next=q;</span><br><span class="line">    <span class="keyword">return</span> LA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="火车站"><a href="#火车站" class="headerlink" title="火车站"></a>火车站</h3><p>有一列火车车厢进站，可以通过中转站改变出站顺序，现在的问题是，给定入站顺序和出栈顺序后，请问该站 的容纳量至少为多少节车厢？例如，进站顺序为ABCD，出站顺序为DCBA，则该站台的容纳量至少为4.保证出 站顺序合法 第一行输入n，表示总共有n节车厢 第二行输入n个字母表示进站的车厢序列 第三行输入n个字母表示出站的车厢序列 输出x表示站台的容纳量 输入： 5 ABCDE CBEDA 输出： 3 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> In[N];</span><br><span class="line"><span class="keyword">char</span> Out[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    stack&lt;<span class="keyword">char</span>&gt; t;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,In);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,Out);</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t.<span class="built_in">empty</span>()||t.<span class="built_in">top</span>()!=Out[i])&#123;</span><br><span class="line">            t.<span class="built_in">push</span>(In[j]);</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">if</span>(ans&lt;t.<span class="built_in">size</span>())</span><br><span class="line">                ans=t.<span class="built_in">size</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            t.<span class="built_in">pop</span>();</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="画圈"><a href="#画圈" class="headerlink" title="画圈"></a>画圈</h3><p>输入n 表示有一个nxn的地图，地图由星组成，输入两个坐标（x1,y1），（x2,y2），由该两点形成一个 矩形，矩形由“1”组成。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">107</span>][<span class="number">107</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x1,y1,x2,y2;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(((i==x1||i==x2)&amp;&amp;j&gt;=y1&amp;&amp;j&lt;=y2)||((j==y1||j==y2)&amp;&amp;i&gt;=x1&amp;&amp;i&lt;=x2))</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;1&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;*&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="QAQ"><a href="#QAQ" class="headerlink" title="QAQ"></a>QAQ</h3><p>输入一行行由大写字母组成的字符串，数一数有多少个QAQ？QAQ三个字母任意一个位置不同，则总数+1，例如 QAQQ 位置123，算一个QAQ，而位置124也算一个QAQ，因此共有两个QAQ，答案为2 输入： QAQAQBCDEF 输出： 4 解释：123，125，145，345 (数字代表字母的位置)，以上共有4个QAQ</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span> arr[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(arr);</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]==<span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;len;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j]==<span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k=j+<span class="number">1</span>;k&lt;len;k++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(arr[k]==<span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">                            cnt++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span> arr[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(arr);</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pre[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i<span class="number">-1</span>]==<span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">            pre[i]=pre[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pre[i]=pre[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]==<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">            cnt+=pre[i]*(pre[len]-pre[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> arr[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,arr);</span><br><span class="line">    cout&lt;&lt;<span class="built_in">fun</span>(arr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后缀表达式"><a href="#后缀表达式" class="headerlink" title="后缀表达式"></a>后缀表达式</h3><p>编写函数，求后缀表达式的值，后缀表达式存在一个字符数组exp中，假设后缀式的数字都只有一位。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">op</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">char</span> op,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="string">&#x27;+&#x27;</span>) <span class="keyword">return</span> a+b;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="string">&#x27;-&#x27;</span>) <span class="keyword">return</span> a-b;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="string">&#x27;*&#x27;</span>) <span class="keyword">return</span> a*b;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (a*<span class="number">1.0</span>)/(b*<span class="number">1.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span> exp[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(exp);</span><br><span class="line">    <span class="keyword">double</span> stack[N];</span><br><span class="line">    <span class="keyword">int</span> top=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(exp[i]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;exp[i]&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            stack[++top]=exp[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">double</span> a,b,c;</span><br><span class="line">            b=stack[top--];</span><br><span class="line">            a=stack[top--];</span><br><span class="line">            c=<span class="built_in">op</span>(a,exp[i],b);</span><br><span class="line">            stack[++top]=c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack[top];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a);</span><br><span class="line">    cout&lt;&lt;<span class="built_in">fun</span>(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="逆序无头结点单链表"><a href="#逆序无头结点单链表" class="headerlink" title="逆序无头结点单链表"></a>逆序无头结点单链表</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reserve</span><span class="params">(Linklist &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L==<span class="literal">NULL</span>&amp;&amp;L-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    LNode *p=L;</span><br><span class="line">    L=<span class="literal">NULL</span>;</span><br><span class="line">    LNode *q=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        q=p-&gt;next;</span><br><span class="line">        p-&gt;next=L;</span><br><span class="line">        L=p;</span><br><span class="line">        p=q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="区间反转"><a href="#区间反转" class="headerlink" title="区间反转"></a>区间反转</h3><p>将一个节点数为 size 链表 m 位置到 n 位置之间的区间反转，要求时间复杂度 O(n)，空间复杂度 O(1)。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head,<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n-m==<span class="number">0</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">    ListNode *p=head;</span><br><span class="line">    ListNode *last=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(cnt&lt;m)&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        last=p;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode *left=p;</span><br><span class="line">    ListNode *nxt;</span><br><span class="line">    ListNode *pre=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;cnt&lt;=n)&#123;</span><br><span class="line">        nxt=p-&gt;next;</span><br><span class="line">        p-&gt;next=pre;</span><br><span class="line">        pre=p;</span><br><span class="line">        p=nxt;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(last!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        last-&gt;next=pre;</span><br><span class="line">        Left-&gt;next=p;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        head-&gt;next=p;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="判断是否有环"><a href="#判断是否有环" class="headerlink" title="判断是否有环"></a>判断是否有环</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(Linklist head)</span></span>&#123;</span><br><span class="line">    ListNode *p=head;</span><br><span class="line">    ListNode *q=head;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">NULL</span>||p-&gt;next==<span class="literal">NULL</span>||p-&gt;next-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        p=p-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(p==q)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        q=q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第一次习题课&quot;&gt;&lt;a href=&quot;#第一次习题课&quot; class=&quot;headerlink&quot; title=&quot;第一次习题课&quot;&gt;&lt;/a&gt;第一次习题课&lt;/h2&gt;&lt;h3 id=&quot;阶乘和&quot;&gt;&lt;a href=&quot;#阶乘和&quot; class=&quot;headerlink&quot; title=&quot;阶乘和</summary>
      
    
    
    
    
    <category term="考研" scheme="https://insistgang.github.io/tags/%E8%80%83%E7%A0%94/"/>
    
    <category term="datastruct" scheme="https://insistgang.github.io/tags/datastruct/"/>
    
  </entry>
  
  <entry>
    <title>第七章排序</title>
    <link href="https://insistgang.github.io/posts/f593ace5.html"/>
    <id>https://insistgang.github.io/posts/f593ace5.html</id>
    <published>2022-08-10T12:07:39.000Z</published>
    <updated>2022-11-11T06:41:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="七、排序"><a href="#七、排序" class="headerlink" title="七、排序"></a>七、排序</h1><p>1.时间复杂度</p><p>​    平均情况下，快排，希尔排序（复杂度了解即可）、归并排序和堆排序的复杂度为O(nlog²n)，其他都是O(n²)。一个特殊的是计数排序，其复杂度为O(n*k)</p><p>​    最坏情况下，快速排序的为O(n²)，其他都和平均情况下相同</p><p>2.空间复杂度</p><p>​    快排O(nlog²n)，归并O(n)，基数O(n+k)，其他都是O(1)</p><p><strong>快排、希尔、简单选择、堆排序是不稳定的，其余均为稳定的。</strong> </p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>时间复杂度：最好O(n)    最坏O(n²)    平均O(n²)        </p><p>空间复杂度：O(1)</p><p><em><strong>稳定</strong></em></p><h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> t = arr[i];<span class="comment">//t等于当前元素</span></span><br><span class="line"><span class="keyword">int</span> j = i;<span class="comment">//j从当前元素开始往前看</span></span><br><span class="line"><span class="keyword">while</span>(j&amp;&amp;t &lt; arr[j<span class="number">-1</span>])&#123;<span class="comment">//j&gt;0且前一个元素也是大于t的时候</span></span><br><span class="line">arr[j] = arr[j<span class="number">-1</span>];<span class="comment">//将前一个元素往后移动一位</span></span><br><span class="line">j--;<span class="comment">//j往前移动一位</span></span><br><span class="line">&#125;</span><br><span class="line">arr[j] = t;<span class="comment">//将t放到对应的元素上</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binary_sort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="comment">//如果前一个元素比当前元素要小或相等我们就不需要改变位置直接跳过，否则必然存在比当前元素大的元素</span></span><br><span class="line">        <span class="keyword">if</span>(a[i<span class="number">-1</span>]&lt;a[i])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> t=a[i],l=<span class="number">0</span>,r=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(a[mid]&gt;t)<span class="comment">//如果中间元素是大于当前元素</span></span><br><span class="line">                r=mid;<span class="comment">//二分的点为当前元素的左边</span></span><br><span class="line">            <span class="keyword">else</span> l=mid+<span class="number">1</span>;<span class="comment">//二分的点为当前元素的右边</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i<span class="number">-1</span>;j&gt;=r;j--)&#123;<span class="comment">//将i-1开始到r这一部分元素从后往前移动一位</span></span><br><span class="line">            a[j+<span class="number">1</span>]=a[j];</span><br><span class="line">        &#125;</span><br><span class="line">        a[r]=t;<span class="comment">//将当前元素存放到r的位置上</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>时间复杂度：最好O(nlog²n) 最坏O(nlog²n) 平均O(nlogn)</p><p>空间复杂度：O(1)</p><p>不稳定排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂的O(n^2)</span></span><br><span class="line"><span class="comment">//空间复杂度O(1)</span></span><br><span class="line"><span class="comment">//稳定性：不稳定排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="keyword">int</span> num[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> d = len / <span class="number">2</span>;d &gt; <span class="number">0</span>;d /= <span class="number">2</span>)&#123;<span class="comment">//逐渐缩小间隔，最终为1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> start = <span class="number">0</span>;start &lt; d;start++)&#123;<span class="comment">//枚举一下每个序列的起点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = start + d;i &lt; len ; i++)&#123;<span class="comment">//在这里做插入排序</span></span><br><span class="line">                <span class="keyword">int</span> t = num[i];</span><br><span class="line">                <span class="keyword">int</span> j = i;<span class="comment">//从下标为0开始存储</span></span><br><span class="line">                <span class="keyword">while</span>(j &gt; start &amp;&amp; num[j - d] &gt; t)&#123;</span><br><span class="line">                    num[j] = num[j - d];</span><br><span class="line">                    j -= d;<span class="comment">//依次移动step个位置</span></span><br><span class="line">                &#125;</span><br><span class="line">                num[j] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>时间复杂度：最好O(n)    最坏O(n²)    平均O(n²)</p><p>空间复杂度  O(1)</p><p><em><strong>稳定</strong></em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bubble_Sort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>时间复杂度：最好O(nlogn)    最坏为O(n²)    平均O(nlogn)        </p><p>空间复杂度：O(logn)</p><p>不稳定</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Quick_Sort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = l,j = r;</span><br><span class="line">    <span class="keyword">if</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[l];</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="comment">//从右向左找第一个小于temp的数</span></span><br><span class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; arr[j] &gt;= temp)</span><br><span class="line">                j--;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">                arr[i] = arr[j];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//从左向右找第一个大于等于temp的数</span></span><br><span class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; arr[i] &lt; temp)</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">                arr[j] = arr[i];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归调用</span></span><br><span class="line">    <span class="built_in">Quick_Sort</span>(arr,l, i - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">Quick_Sort</span>(arr,i + <span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>时间复杂度：最好O(n)    最坏O(n²)    平均O(n²)</p><p>空间复杂度：O(1)</p><p>不稳定</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Selection_Sort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; len - <span class="number">1</span> ; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = i;<span class="comment">// 记录最小值，第一个元素默认最小</span></span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; len; j++)<span class="comment">// 访问未排序的元素</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[k])<span class="comment">// 找到目前最小值</span></span><br><span class="line">                k = j;    <span class="comment">// 记录最小值  </span></span><br><span class="line">        <span class="keyword">if</span>(k != i)&#123;</span><br><span class="line">            temp=arr[min]; <span class="comment">// 交换两个变量</span></span><br><span class="line">            arr[min]=arr[i];</span><br><span class="line">            arr[i]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆排序-看成完全二叉树，根结点要么最大要么最小"><a href="#堆排序-看成完全二叉树，根结点要么最大要么最小" class="headerlink" title="堆排序(看成完全二叉树，根结点要么最大要么最小)"></a>堆排序(看成完全二叉树，根结点要么最大要么最小)</h3><p>时间复杂度：最好O(nlogn)    最坏为O(nlogn)    平均O(nlogn)</p><p>空间复杂度：O(1)</p><p>不稳定</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先“筛选” （堆顶到叶子的调整过程）</span></span><br><span class="line"><span class="comment">//在 low 到 high 范围内对 low 进行调整</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sift</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line">i=low,j=<span class="number">2</span>*i;</span><br><span class="line"><span class="keyword">int</span> temp=arr[low];<span class="comment">//以 low 为根向下交换</span></span><br><span class="line"><span class="keyword">while</span>(j&lt;=high)&#123;</span><br><span class="line"><span class="keyword">if</span>(j&lt;high&amp;&amp;arr[j]&lt;arr[j+<span class="number">1</span>])<span class="comment">//大顶堆 与较大的孩子进行比较</span></span><br><span class="line">j++;</span><br><span class="line"><span class="keyword">if</span>(temp&lt;arr[j])&#123;</span><br><span class="line">arr[i]=arr[j];</span><br><span class="line">i=j;</span><br><span class="line">            j=<span class="number">2</span>*i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">arr[i]=temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heap_Sort</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> arr[])</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n/<span class="number">2</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line"><span class="built_in">sift</span>(arr,i,n);<span class="comment">//建堆</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">2</span>;i--)&#123;<span class="comment">//排序</span></span><br><span class="line">temp=arr[<span class="number">1</span>];<span class="comment">//每次和最大值交换</span></span><br><span class="line">arr[<span class="number">1</span>]=arr[i];</span><br><span class="line">arr[i]=temp;</span><br><span class="line"><span class="built_in">sift</span>(arr,<span class="number">1</span>,i<span class="number">-1</span>);<span class="comment">//只需要调整一次就好</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二路归并排序"><a href="#二路归并排序" class="headerlink" title="二路归并排序"></a>二路归并排序</h3><p>时间复杂度：最好O(nlogn)    最坏为O(nlogn)    平均O(nlogn)</p><p>空间复杂度：O(n)</p><p><em><strong>稳定</strong></em></p><p>思想：先两两归并，然后两两归并，最后两两归并</p><p>对于一个左边一半和右边一半分别有序的数组，合并成一个新的整体有序的数组，需要注意的是，这里需要一个和原数组一样大的辅助空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergrSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> n,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">MergrSort</span>(arr, low, mid);<span class="comment">//递归排序左边，下标从low到mid是有序</span></span><br><span class="line">        <span class="built_in">MergrSort</span>(arr, mid+<span class="number">1</span>, high);<span class="comment">//递归排序右边，下标从mid到high是有序的</span></span><br><span class="line">        <span class="keyword">int</span> temp[Maxn];<span class="comment">//新开一个数组来辅助排序，将两个有序数组合并成一个有序数组</span></span><br><span class="line">        <span class="keyword">int</span> i = low,j = mid + <span class="number">1</span>,k = <span class="number">0</span>;<span class="comment">//i从左区间的第一个元素开始走，j从右区间第一个元素开始走，k是临时数组下标</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= high)&#123;<span class="comment">//如果左右区间都没有走完</span></span><br><span class="line">            <span class="keyword">if</span>(arr[i] &lt;= arr[j])&#123;<span class="comment">//如果左边的值小于右边的值</span></span><br><span class="line">                temp[k++] = arr[i++];<span class="comment">//将左边的值赋值给临时数组</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                temp[k++] = arr[j++];<span class="comment">//将右边的值赋值给临时数组</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid)&#123;<span class="comment">//如果左边没有走完，继续赋值。</span></span><br><span class="line">            temp[k++] = arr[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= high)&#123;<span class="comment">//如果右边没有走完，继续赋值。</span></span><br><span class="line">            temp[k++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = low,j = <span class="number">0</span>;j &lt; k;i++,j++)<span class="comment">//将临时数组的元素复制给原数组</span></span><br><span class="line">            arr[i] = temp[j];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>时间复杂度：最好O(n * k)    最坏为O(n * k)    平均O(n * k)</p><p>空间复杂度：O(n + k)</p><p><em><strong>稳定</strong></em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;七、排序&quot;&gt;&lt;a href=&quot;#七、排序&quot; class=&quot;headerlink&quot; title=&quot;七、排序&quot;&gt;&lt;/a&gt;七、排序&lt;/h1&gt;&lt;p&gt;1.时间复杂度&lt;/p&gt;
&lt;p&gt;​    平均情况下，快排，希尔排序（复杂度了解即可）、归并排序和堆排序的复杂度为O(nlog</summary>
      
    
    
    
    
    <category term="考研" scheme="https://insistgang.github.io/tags/%E8%80%83%E7%A0%94/"/>
    
    <category term="datastruct" scheme="https://insistgang.github.io/tags/datastruct/"/>
    
  </entry>
  
  <entry>
    <title>第六章查找</title>
    <link href="https://insistgang.github.io/posts/4bd3708b.html"/>
    <id>https://insistgang.github.io/posts/4bd3708b.html</id>
    <published>2022-08-10T12:07:22.000Z</published>
    <updated>2022-10-20T14:56:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="六、查找"><a href="#六、查找" class="headerlink" title="六、查找"></a>六、查找</h1><h3 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span>(a[i] == k)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="折半查找（二分查找）"><a href="#折半查找（二分查找）" class="headerlink" title="折半查找（二分查找）"></a>折半查找（二分查找）</h3><p>时间复杂度：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span><span class="title">BSearch</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid] == k)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span>(a[mid] &gt; k)</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h3><p>时间复杂度：<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAASCAIAAAAi++zfAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAK4SURBVFhHY/z//z/DKCAOMEHpUUAEGA0sEgCBwHqwIkSMg5GxcD+UP7IBgcBSiFizpVIUyhnxgHA2FJZWg7JGPCCxzHp3fk6iEShjMvLJuFftfvwbLPr71eE2dxk+oCgM2My5C5bBAX6/2l2lw8co13jq97vzk/yBBvJ5zL8FMWwwA2DTAT+4M9uaoWAfmPlkRQC7aOyqe9////9+dbojO4PuxKtA4RdrwthFs7a//PX/+72FgeyiBfs+gpXjBLfmFk6/+mlXFoNndWvlxNMvf92cbsZgPfsOVHrQAlIC6/48Rwb17otgUSC42K0O8eG+AgZYcIJVE+dtkGmiWbvegtjAwGIvPQgWHsyAlGz49+8vBhEBbiiPgVtABMLQsghgWLpmx6vfwOx16dAZdg1pSJXw4/6OKgdQnuXTSVyJnsk+Xdm/X7cm21UIyH55fuepMDsDiMQgBiSWWQy3nr6Fshi+fnjDwMbMzMAgHtTUo7g4TI6NkU0l92Xd/i5PPpD83SWxZXz9j378ernQaHnpmstgTXBw4+wO0WALLRDz0+mtGwK8TcGaBjeApjDc4GSDKEPsZnApdHWiLgO74/SroDLr3qpYUfaAFU+AwnfmOYaveglSgANc7NZN3oZajoHyMNRUsA0F+96em9i/5TVYYLACQoF1tJIXFKS8fsvvA3m/Hu2qdJMGibCLGibMPgcucP6/3VcgC1IEBbzaedtAYQgFv27Oy209BlEJBy9WBDA4zgMZCQRP1oTxMvBaYCgadIBwyiIInmxNMoQW1EDw6+WqcEQR/+vm4sKuQR8IxAJSyyws4NbueU8Yfn79DCrBf39+ce/uE2gR//vW/LQF0jWllkK/j9c0DoceEzTQKADgvKksyg42jlfaLXcJJHuCWmVgMTCAtS2GMhgdzyIBUCEbjhTAwAAAuF7Tj/yvtTQAAAAASUVORK5CYII=" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> low,high;<span class="comment">//记录某块中第一个和最后一个元素的位置</span></span><br><span class="line">&#125;indexElem;</span><br><span class="line">indexElem index[MaxSize];<span class="comment">//定义索引表</span></span><br><span class="line"><span class="comment">//k是需要查找的数字  arr[]表示原数组  index是结构体类型的索引表</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Block_Search</span><span class="params">(indexElem index[],<span class="keyword">int</span> k,<span class="keyword">int</span> n,<span class="keyword">int</span> arr[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j,k;</span><br><span class="line">    <span class="comment">//寻找第一个块内最大关键字 &gt;= k 的块 </span></span><br><span class="line">    <span class="keyword">while</span>((i &lt; n) &amp;&amp; index[i].key &lt; k)</span><br><span class="line">        i++;</span><br><span class="line">    <span class="keyword">if</span>(i &gt;= n)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nNot found&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从块内查找</span></span><br><span class="line">    j = index[i].low;</span><br><span class="line">    <span class="keyword">while</span>((j &lt;= index[i].high) &amp;&amp; arr[j] != k)</span><br><span class="line">        j++;</span><br><span class="line">    <span class="comment">//查找越界</span></span><br><span class="line">    <span class="keyword">if</span>(j &gt; index[i].high)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nNot found&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h3><h4 id="BST树的查找（类比一下二分查找）"><a href="#BST树的查找（类比一下二分查找）" class="headerlink" title="BST树的查找（类比一下二分查找）"></a>BST树的查找（类比一下二分查找）</h4><p>思想：</p><p>首先将给定的k值与二叉排序树的根结点的关键字进行比较，若相等，则查找成功；</p><p>① 给定的k值小时BST的根结点的关键字，继续在该结点的左子树上进行查找；</p><p>② 给定的k值大于BST的根结点的关键字，继续在该结点的右子树上进行查找。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> *<span class="title">lchild</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BTNode;</span><br><span class="line"></span><br><span class="line"><span class="function">BTNode *<span class="title">research</span><span class="params">(BTNode *t,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t == <span class="literal">NULL</span>)<span class="comment">//1.递归结束条件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t-&gt;key == k)<span class="comment">//2.解决本次步骤</span></span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(k &lt; t-&gt;key)<span class="comment">//3.递归转移方程</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">research</span>(t-&gt;lchild, k);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">research</span>(t-&gt;rchild, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插入关键字算法"><a href="#插入关键字算法" class="headerlink" title="插入关键字算法"></a>插入关键字算法</h4><p>在插入过程中如果待插入关键字已经存在，则返回0，代表插入不成功；</p><p>如果待插入关键字不存在，则插入，并返回1，代表插入成功。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Insert</span><span class="params">(BTNode *t,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="comment">//t为当前查找的结点（可能是根结点也可能不是）</span></span><br><span class="line">    <span class="keyword">if</span>(t == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        t = <span class="keyword">new</span> BTNode;<span class="comment">//创建一个新结点（c++语法）</span></span><br><span class="line">        t-&gt;key = key;</span><br><span class="line">        t-&gt;lchild = t-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">       <span class="comment">//查找成功不需要插入</span></span><br><span class="line">        <span class="keyword">if</span>(key == t-&gt;key)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">        <span class="comment">//key 值小于当前结点，在左子树插入</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; t-&gt;key)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Insert</span>(t-&gt;lchild, key);</span><br><span class="line">        <span class="comment">//key 值大于当前结点，在右子树插入</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Insert</span>(t-&gt;rchild, key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉排序树的构造算法"><a href="#二叉排序树的构造算法" class="headerlink" title="二叉排序树的构造算法"></a>二叉排序树的构造算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建立一个空树,每个数据元素都用插入算法插入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Create</span><span class="params">(BTNode *t,<span class="keyword">int</span> arr[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">Insert</span>(t,arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;六、查找&quot;&gt;&lt;a href=&quot;#六、查找&quot; class=&quot;headerlink&quot; title=&quot;六、查找&quot;&gt;&lt;/a&gt;六、查找&lt;/h1&gt;&lt;h3 id=&quot;顺序查找&quot;&gt;&lt;a href=&quot;#顺序查找&quot; class=&quot;headerlink&quot; title=&quot;顺序查找&quot;&gt;&lt;/a</summary>
      
    
    
    
    
    <category term="考研" scheme="https://insistgang.github.io/tags/%E8%80%83%E7%A0%94/"/>
    
    <category term="datastruct" scheme="https://insistgang.github.io/tags/datastruct/"/>
    
  </entry>
  
  <entry>
    <title>第五章图</title>
    <link href="https://insistgang.github.io/posts/6428e5d6.html"/>
    <id>https://insistgang.github.io/posts/6428e5d6.html</id>
    <published>2022-08-10T12:07:02.000Z</published>
    <updated>2022-10-13T11:55:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第五章图"><a href="#第五章图" class="headerlink" title="第五章图"></a>第五章图</h1><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p>基本思想：vexNum表示顶点数量，arcNum表示边数量，edges表示边（1或者权值）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MGraph</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> edge[Maxn][Maxn];<span class="comment">//存储边edge[i][j]=MAXN 表示两个顶点不通</span></span><br><span class="line">    <span class="keyword">int</span> vexNum,arcNum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span><span class="comment">//边结构</span></span><br><span class="line"><span class="keyword">int</span> adjvex;<span class="comment">//顶点编号一条边里 被指向的那个顶点</span></span><br><span class="line">ArcNode *next;<span class="comment">//指针</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span><span class="comment">//顶点结构</span></span><br><span class="line"><span class="keyword">int</span> data;<span class="comment">//顶点信息</span></span><br><span class="line">ArcNode *firstarc;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AGraph</span>&#123;</span><span class="comment">//表</span></span><br><span class="line">VNode adjlist[Maxn];<span class="comment">//存储所有顶点链表  存了所有顶点 以及他们所指向的边</span></span><br><span class="line"><span class="keyword">int</span> vexNum,arcNum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><h3 id="图的深度优先遍历"><a href="#图的深度优先遍历" class="headerlink" title="图的深度优先遍历"></a>图的深度优先遍历</h3><h4 id="思想"><a href="#思想" class="headerlink" title="思想:"></a>思想:</h4><p>1.首先，访问开始结点从起始结点开始任选一个相邻并未被访问的结点，访问；</p><p>2.接着，把找到的结点作为起始结点继续访问其相邻且未被访问的一个结点;</p><p>3.重复 2 的操作直到某一个结点所有相邻结点都被访问，则退回最近被访问且还有相邻结点 未被访问的结点； </p><p>4.把 3 中结点作为起始结点继续执行 2，3 操作直到所有结点都被访问完为止。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(AGraph *g,<span class="keyword">int</span> v,<span class="keyword">int</span> vis[])</span></span>&#123;<span class="comment">//标记数组初始化为0</span></span><br><span class="line">    ArcNode *p;<span class="comment">//用来指向节点的边（访问）</span></span><br><span class="line">    vis[v] = <span class="number">1</span>;<span class="comment">//可以定义为全局变量</span></span><br><span class="line">    <span class="built_in">visit</span>(v);<span class="comment">//访问开始节点</span></span><br><span class="line">    p = g-&gt;adjlist[v].firstarc; <span class="comment">//顶点v的第1个边</span></span><br><span class="line">    <span class="comment">//从起始节点开始任选一个相邻且未被访问的节点</span></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">//未被访问</span></span><br><span class="line">        <span class="keyword">if</span>(vis[p-&gt;adjvex != <span class="number">1</span>])</span><br><span class="line">            <span class="comment">//把找到的节点作为起始节点继续访问</span></span><br><span class="line">            <span class="built_in">DFS</span>(g,p-&gt;adjvex, vis);</span><br><span class="line">        <span class="comment">//则退回最近被访问且还有相邻节点未被访问的节点</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图的广度优先遍历"><a href="#图的广度优先遍历" class="headerlink" title="图的广度优先遍历"></a>图的广度优先遍历</h3><h4 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h4><p>1.首先，从起始结点出发访问其所有相邻的且未被访问的结点，并把访问的结点入队；<br>2.接着，当队列不为空时候队首元素出队并将其作为起始结点执行 1 操作;<br>3.最后重复执行 2 操作直到队列为空或者所有结点都访问完毕为止。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(AGraph *g,<span class="keyword">int</span> v,<span class="keyword">int</span> vis[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> que[Maxn];</span><br><span class="line">    <span class="keyword">int</span> front = rear = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">visit</span>(v);</span><br><span class="line">    vis[v] = <span class="number">1</span>;<span class="comment">//遍历顶点v</span></span><br><span class="line">    que[++rear] = v;<span class="comment">//把顶点v入队</span></span><br><span class="line">    ArcNode *p;<span class="comment">//指向相邻的边</span></span><br><span class="line">    <span class="keyword">while</span>(front &lt; rear)&#123;<span class="comment">//队不为空</span></span><br><span class="line">        <span class="keyword">int</span> k = que[++front];<span class="comment">//取出队首元素</span></span><br><span class="line">        p = g-&gt;adjlist[k].firstarc;<span class="comment">//指向队首元素的边（相邻的节点）</span></span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">//若未被访问</span></span><br><span class="line">            <span class="keyword">if</span>(vis[p-&gt;adkvex] == <span class="number">0</span>)&#123;</span><br><span class="line">                que[++rear] = p-&gt;adjvex;<span class="comment">//入队</span></span><br><span class="line">                <span class="built_in">visit</span>(p-&gt;adjvex);<span class="comment">//访问</span></span><br><span class="line">                vis[p-&gt;adjvex] = <span class="number">1</span>;<span class="comment">//标记为已被访问</span></span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图不连通的时候（一个顶点不足以访问全部的顶点）"><a href="#图不连通的时候（一个顶点不足以访问全部的顶点）" class="headerlink" title="图不连通的时候（一个顶点不足以访问全部的顶点）"></a>图不连通的时候（一个顶点不足以访问全部的顶点）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//深度优先遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(AGraph *g,<span class="keyword">int</span> v,<span class="keyword">int</span> vis[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; g-&gt;vexNum;i++)</span><br><span class="line">        <span class="keyword">if</span>(vis[i] == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">DFS</span>(g,v,vis);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//广度优先遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(AGraph *g,<span class="keyword">int</span> v,<span class="keyword">int</span> vis[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)</span><br><span class="line">        <span class="keyword">if</span>(vis[i] == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">BFS</span>(g,v,vis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p>如果连通图是个带权图，则其生成树中的边也带权，生成树中所有边的权值之和称为生成树的代价。</p><p>最小生成树：带权连通图中代价最小的生成树称为最小生成树。</p><h4 id="prim（普里姆算法）：归并点"><a href="#prim（普里姆算法）：归并点" class="headerlink" title="prim（普里姆算法）：归并点"></a>prim（普里姆算法）：归并点</h4><p>思想：</p><p>1.从起点顶点开始，将与起始顶点相邻的边作为候选边；</p><p>2.从候选边中挑选一条最短且不与生成树构成回路的路径输出，并将这一条边（包含顶点）加入生成树中，将与这条边相邻的边加入候选边中；</p><p>3.重复执 2 操作，直到所有节点都被访问。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Prim</span><span class="params">(MGraph *g,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;<span class="comment">//权值和</span></span><br><span class="line">    <span class="keyword">int</span> vis[Maxn];</span><br><span class="line">    <span class="keyword">int</span> lowcost[Maxn];<span class="comment">//生成树到其余顶点最小距离</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; g-&gt;vexNum;i++)&#123;</span><br><span class="line">        <span class="comment">//候选边初始化</span></span><br><span class="line">        lowcost[i] = g-&gt;edges[v][i];</span><br><span class="line">        vis[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[v] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j, k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; g-&gt;vexNum;i++)&#123;<span class="comment">//循环次数 n-1次</span></span><br><span class="line">        <span class="keyword">int</span> minnest = Maxn;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; g-&gt;vexNum;j++)&#123;<span class="comment">//找最小值</span></span><br><span class="line">            <span class="comment">//从候选边中选出最小边且不与生成树构成回路</span></span><br><span class="line">            <span class="keyword">if</span>(lowcost[j] &lt; minnest &amp;&amp; vis[j] == <span class="number">0</span>)&#123;</span><br><span class="line">                minnest = lowcost[j];</span><br><span class="line">                k = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sum += minnest;</span><br><span class="line">    vis[k] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//维护候选边中的最小值</span></span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">1</span>;j &lt; g-&gt;vexNum;j++)&#123;</span><br><span class="line">        <span class="comment">//只有未被访问过的顶点才可能更换权值</span></span><br><span class="line">        <span class="keyword">if</span>(vis[j] == <span class="number">0</span> &amp;&amp; g-&gt;edges[k][j] &lt; lowcost[j])</span><br><span class="line">            <span class="comment">//维护到生成树的最小距离</span></span><br><span class="line">            lowcost[j] = g-&gt;edges[k][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="克鲁斯卡尔：归并边"><a href="#克鲁斯卡尔：归并边" class="headerlink" title="克鲁斯卡尔：归并边"></a>克鲁斯卡尔：归并边</h4><p>思想：</p><p>1.将图中的边按照权值从小到大进行排序；</p><p>2.从最小边开始扫描，如果加入生成树中不构成回路，则加入生成树；并查集判断是否构成回路（判断边的两个顶点的根节点是否相同）</p><p>3.重复 2 操作，直到所有边都被扫描为止。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Road</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b;<span class="comment">//两个边的顶点</span></span><br><span class="line">    <span class="keyword">int</span> weight;<span class="comment">//权值</span></span><br><span class="line">    boll <span class="keyword">operator</span> &lt; (Road a)<span class="keyword">const</span>&#123;<span class="comment">//固定写法   在sort()中应用cmp</span></span><br><span class="line">        <span class="keyword">return</span> weight &lt; a.weight;<span class="comment">//从小到大排序 (&gt; 从大到小)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> v[Maxn];<span class="comment">//并查集数组</span></span><br><span class="line"><span class="comment">//返回并查集数组中下标为a的根结点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getRoot</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(a != v[a])<span class="comment">//v[a]指向a的父亲节点</span></span><br><span class="line">        a = v[a];  </span><br><span class="line">    retur a;<span class="comment">//返回a的根节点</span></span><br><span class="line">&#125;</span><br><span class="line">Road road[Maxn];<span class="comment">//存储边的数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kruskal</span><span class="params">(MGraph *g,<span class="keyword">int</span> v)</span></span>&#123;<span class="comment">//AGraph：邻接表 MGraph：邻接矩阵</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;<span class="comment">//权值和</span></span><br><span class="line">    <span class="keyword">int</span> e = g-&gt;arcNum;<span class="comment">//边</span></span><br><span class="line">    <span class="keyword">int</span> v = g-&gt;vexNum;<span class="comment">//顶点个数</span></span><br><span class="line">    <span class="comment">//从下标为1开始到 1+e （不包括），应用cmp函数进行排序</span></span><br><span class="line">    <span class="built_in">sort</span>(road + <span class="number">1</span>,road + <span class="number">1</span> + e , cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= v; i++)</span><br><span class="line">        v[i] = i;<span class="comment">//并查集数组初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= e; ++i)&#123;<span class="comment">//从小到大遍历边</span></span><br><span class="line">        <span class="keyword">int</span> a = <span class="built_in">getRoot</span>(road[i].a);</span><br><span class="line">        <span class="keyword">int</span> b = <span class="built_in">getRoot</span>(road[i].b);</span><br><span class="line">        <span class="comment">//判断根节点是否相等</span></span><br><span class="line">        <span class="keyword">if</span>(a != b)&#123;</span><br><span class="line">            sum += road[i].weight;</span><br><span class="line">            <span class="keyword">if</span>(a &lt; b)</span><br><span class="line">                v[a] = b;<span class="comment">//将a加入b的并查集，把b（大的）作为父节点</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                v[b] = a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><h4 id="迪杰斯特拉-："><a href="#迪杰斯特拉-：" class="headerlink" title="迪杰斯特拉  ："></a>迪杰斯特拉  ：</h4><p>最短路径        单源点最短路径   <strong>和prim对比记忆</strong></p><p>思想：</p><p>1.将起始结点v并入空集S中，将其余结点并入空集T中；</p><p>2.从T中选出一条到v顶点中的最短路径，加入集合S中，并更新v到T中其余各顶点的最短路径；（不能重复访问）prim</p><p>3.重复 2 操作直到所有顶点都并入S中为止。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(MGraph *g, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> vis[Maxn];<span class="comment">//标记数组</span></span><br><span class="line">    <span class="comment">//v到任一顶点的前一顶点，标记路径path[i]:到顶点i的前一个顶点</span></span><br><span class="line">    <span class="keyword">int</span> path[Maxn];</span><br><span class="line">    <span class="keyword">int</span> dist[Maxn];<span class="comment">//v到其余顶点的路径长度，候选边</span></span><br><span class="line">    <span class="comment">//初始化三个数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; g-&gt;vexNum; i++)&#123;</span><br><span class="line">        dist[i] = g-&gt;edges[v][i];<span class="comment">//候选边赋值</span></span><br><span class="line">        vis[i] = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        if(g-&gt;edges[v][i] &lt; Maxn)//v与i之间有路径</span></span><br><span class="line"><span class="comment">            path[i] = v;</span></span><br><span class="line"><span class="comment">        else</span></span><br><span class="line"><span class="comment">            path[i] = -1;//表示v不能到达i</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">    vis[v] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//path[v] = -1;//顶点v自身</span></span><br><span class="line">    <span class="keyword">int</span> k;<span class="comment">//标记最小值位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; g-&gt;vexNum;i++)&#123;<span class="comment">//执行n-1次归并n-1个顶点</span></span><br><span class="line">        <span class="keyword">int</span> minn = Maxn;</span><br><span class="line">        <span class="comment">//取未被访问过的最小值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; g-&gt;vexNum;j++)</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &lt; minn &amp;&amp; vis == <span class="number">0</span>)&#123;</span><br><span class="line">                minn = dist[j];</span><br><span class="line">                k = j;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[k] = <span class="number">1</span>;<span class="comment">//除了之前的最短路径 v-&gt;k-&gt;j(任意顶点) 和prim算法对比记忆</span></span><br><span class="line">    <span class="comment">//维护最短路径</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; g-&gt;vexNum;j++)</span><br><span class="line">        <span class="keyword">if</span>(vis[j] == <span class="number">0</span> &amp;&amp; dist[k] + edges[k][j] &lt; dist[j])&#123;</span><br><span class="line">            dist[j] = dist[k] + edges[k][j];</span><br><span class="line">            <span class="comment">//path[j] = k;//j的前一个顶点就是k</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印路径 从后往前需要栈 path[j]:存储到顶点j的前一个顶点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">int</span> path[], <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> stc[Maxn];</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(path[j] != <span class="number">-1</span>)&#123;<span class="comment">//有路径</span></span><br><span class="line">        stc[++top] = j;<span class="comment">//进栈</span></span><br><span class="line">        j = path[j];<span class="comment">//j指向前一个顶点</span></span><br><span class="line">    &#125;</span><br><span class="line">    stc[++top] = j;</span><br><span class="line">    <span class="comment">//栈的输出</span></span><br><span class="line">    <span class="keyword">while</span>(top != <span class="number">-1</span>)</span><br><span class="line">        cout &lt;&lt; stc[--top] &lt;&lt; <span class="string">&#x27;&#x27;;</span></span><br><span class="line"><span class="string">    cout &lt;&lt; endl;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="弗洛伊德：任意一对顶点的最短路径"><a href="#弗洛伊德：任意一对顶点的最短路径" class="headerlink" title="弗洛伊德：任意一对顶点的最短路径"></a>弗洛伊德：任意一对顶点的最短路径</h4><p>思想：</p><p>1.首先开一个二维数组存放图中各边的权值，再开一个二维数组存放各路径;</p><p>2.接着开个三重循环，外层从1到n表示每次比较中间的结点，中间一层表示行的枚举，最内层表示列的枚举；</p><p>3.利用三重循环，每一次比较边的两端点直接路径与加入中间结点的路径长短，如小于则用加入中间结点的路径值来替代两端点的直接路径值（取它们最小值），并把中间结点接入路径数组中；</p><p>4.完成三个循环结束。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//A用来记录当前已经求得的任意两个顶点最短路径的长度</span></span><br><span class="line"><span class="comment">//path用来记录当前两个顶点间最短路径上要经过的中间结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">(MGraph *g,<span class="keyword">int</span> v,<span class="keyword">int</span> A[][],<span class="keyword">int</span> path[][])</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; g-&gt;vexNum;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; g-&gt;vexNum;j++)&#123;</span><br><span class="line">            A[i][j] = g-&gt;edges[i][j];</span><br><span class="line">            <span class="comment">//将路径初始化为-1 i-&gt;j(没有中间结点)</span></span><br><span class="line">            path[i][j] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//利用三重循环求任意一对顶点的最短路径</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; g-&gt;vexNum;k++)<span class="comment">//中间结点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i &lt; g-&gt;vex)<span class="comment">//行的枚举</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; g-&gt;vexNum;j++)<span class="comment">//列的枚举</span></span><br><span class="line">                <span class="keyword">if</span>(A[i][j] &gt; A[i][k] + A[k][j])&#123;</span><br><span class="line">                    A[i][j] = A[i][k] + A[k][j];</span><br><span class="line">                    path[i][j] = k;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运用递归与中间结点输出路径</span></span><br><span class="line"><span class="comment">//path[i][j]:存储i-&gt;j的中间结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print_f</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> path[][],<span class="keyword">int</span> A[][])</span></span>&#123;</span><br><span class="line">    <span class="comment">//无路径直接返回 终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(A[u][v] == Maxn)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//无中间结点直接输出</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(path[u][v] == <span class="number">-1</span>)</span><br><span class="line">        cout &lt;&lt; u &lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt; v;<span class="comment">//解决本次步骤</span></span><br><span class="line">    <span class="comment">//运用递归与中间结点输出路径  递归转移方程</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = path[u][v];<span class="comment">//存储u-&gt;v的中间结点</span></span><br><span class="line">        <span class="built_in">Print_f</span>(u, mid, path, A);<span class="comment">//递归遍历u-&gt;mid的路径</span></span><br><span class="line">        <span class="built_in">Print_f</span>(mid, v, path, A);<span class="comment">//递归遍历mid-&gt;v的路径</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拓扑排序：判断是否为有向无环图（删除的结点是否为n个）"><a href="#拓扑排序：判断是否为有向无环图（删除的结点是否为n个）" class="headerlink" title="拓扑排序：判断是否为有向无环图（删除的结点是否为n个）"></a>拓扑排序：判断是否为有向无环图（删除的结点是否为n个）</h3><p>思想：从入度为0的结点开始删除（每次删除结点和相关的边）</p><p>1.首先将图中入度为0的结点入栈，栈初始为空；</p><p>2.当栈非空时栈首元素出栈，访问并且将与元素相邻顶点的入度减1；（去掉相关的边）</p><p>3.当某个顶点在去掉相关边后入度为0，则入栈；</p><p>4.重复执行 2 3 操作，并且同届访问顶点个数直到栈空。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> adjvex;</span><br><span class="line">ArcNode *next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="keyword">int</span> cnt;<span class="comment">//入度个数</span></span><br><span class="line">ArcNode *firstarc;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AGraph</span>&#123;</span></span><br><span class="line">VNode adjlist[Maxn];</span><br><span class="line"><span class="keyword">int</span> vexNum,arcNum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Puop</span><span class="params">(AGraph *G)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> stc[Maxn],top = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//访问所有顶点  入度为0入栈</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; G-&gt;vexNum;i++)</span><br><span class="line">        <span class="comment">//1.首先将图中入度为0的结点入栈，栈初始为空</span></span><br><span class="line">        <span class="keyword">if</span>(G-&gt;adjlist[i].cnt == <span class="number">0</span>)</span><br><span class="line">            stc[++top] = i;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    <span class="comment">//2.当栈非空时栈首元素出栈，访问并且将与此元素相邻顶点的入度-1（去掉相关的边）</span></span><br><span class="line">    <span class="keyword">while</span>(top != <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">//出栈</span></span><br><span class="line">        <span class="keyword">int</span> k = stc[top--];</span><br><span class="line">        <span class="built_in">visit</span>(k);</span><br><span class="line">        n++;<span class="comment">//统计出栈元素个数</span></span><br><span class="line">        <span class="comment">//指向顶点k的相邻边</span></span><br><span class="line">        p = G-&gt;adjlist[k].firstarc;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">//取相邻边的顶点</span></span><br><span class="line">            <span class="keyword">int</span> j = p-&gt;adjvex;</span><br><span class="line">            --G-&gt;adjlist[j].cnt;</span><br><span class="line">            <span class="keyword">if</span>(G-&gt;adjlist[j].cnt == <span class="number">0</span>)</span><br><span class="line">                stc[++top] = j;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否有向无环图</span></span><br><span class="line">    <span class="keyword">if</span>(n == G-&gt;vexNum)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求-AOE-中关键路径和关键活动（给你图要会求关键路径）"><a href="#求-AOE-中关键路径和关键活动（给你图要会求关键路径）" class="headerlink" title="求 AOE 中关键路径和关键活动（给你图要会求关键路径）"></a>求 AOE 中关键路径和关键活动（给你图要会求关键路径）</h3><p><img src="../../images/%E5%9B%BE.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第五章图&quot;&gt;&lt;a href=&quot;#第五章图&quot; class=&quot;headerlink&quot; title=&quot;第五章图&quot;&gt;&lt;/a&gt;第五章图&lt;/h1&gt;&lt;h2 id=&quot;邻接矩阵&quot;&gt;&lt;a href=&quot;#邻接矩阵&quot; class=&quot;headerlink&quot; title=&quot;邻接矩阵&quot;&gt;&lt;/a</summary>
      
    
    
    
    
    <category term="考研" scheme="https://insistgang.github.io/tags/%E8%80%83%E7%A0%94/"/>
    
    <category term="datastruct" scheme="https://insistgang.github.io/tags/datastruct/"/>
    
  </entry>
  
  <entry>
    <title>第四章树和二叉树</title>
    <link href="https://insistgang.github.io/posts/a25097f1.html"/>
    <id>https://insistgang.github.io/posts/a25097f1.html</id>
    <published>2022-08-10T12:06:51.000Z</published>
    <updated>2022-11-10T08:49:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第四章树和二叉树"><a href="#第四章树和二叉树" class="headerlink" title="第四章树和二叉树"></a>第四章树和二叉树</h2><h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="comment">//顺序存储结构体定义描述</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> ElemType SqBitree[MAX_SIZE];</span><br><span class="line">SqBiTree bt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链式存储结构</span></span><br><span class="line"><span class="comment">//二叉链表形式：</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BTNode,*BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//三叉链表形式：</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>,*<span class="title">parent</span>;</span></span><br><span class="line">&#125;BTNode,*BiTree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;T-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="二叉树的遍历递归写法"><a href="#二叉树的遍历递归写法" class="headerlink" title="二叉树的遍历递归写法"></a>二叉树的遍历递归写法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">visit</span>(T);   <span class="comment">//访问根节点</span></span><br><span class="line">        <span class="built_in">PreOrder</span>(T-&gt;lchild);<span class="comment">//递归遍历左子树</span></span><br><span class="line">        <span class="built_in">PreOrder</span>(T-&gt;rchild);<span class="comment">//递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">InOrder</span>(T-&gt;lchild);<span class="comment">//递归遍历左子树</span></span><br><span class="line">        <span class="built_in">visit</span>(T);   <span class="comment">//访问根节点</span></span><br><span class="line">        <span class="built_in">InOrder</span>(T-&gt;rchild);<span class="comment">//递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">PostOrder</span>(T-&gt;lchild);<span class="comment">//递归遍历左子树</span></span><br><span class="line">        <span class="built_in">PostOrder</span>(T-&gt;rchild);<span class="comment">//递归遍历右子树</span></span><br><span class="line">        <span class="built_in">visit</span>(T);   <span class="comment">//访问根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="非递归遍历"><a href="#非递归遍历" class="headerlink" title="非递归遍历"></a>非递归遍历</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder2</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    BiTree Stack[MAX_SIZE];<span class="comment">//初始化栈和遍历指针</span></span><br><span class="line">    <span class="keyword">int</span> top=<span class="number">0</span>;</span><br><span class="line">    BiTree p=T;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>||top&gt;<span class="number">0</span>)&#123;<span class="comment">//栈不为空或p不为空时循环</span></span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123; </span><br><span class="line">            <span class="built_in">visit</span>(p);<span class="comment">//访问当前结点</span></span><br><span class="line">            Stack[++top]=p;<span class="comment">//当前结点入栈</span></span><br><span class="line">            p=p-&gt;lchild;<span class="comment">//左孩子不为空一直往左走</span></span><br><span class="line">        &#125;</span><br><span class="line">        p=Stack[top--];<span class="comment">//栈顶元素出栈</span></span><br><span class="line">        p=p-&gt;rchild;<span class="comment">//向右子树走即p赋值为当前结点的右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder2</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    BiTree Stack[MAX_SIZE];<span class="comment">//初始化 栈 和 遍历指针</span></span><br><span class="line">    <span class="keyword">int</span> top=<span class="number">0</span>;    </span><br><span class="line">    BiTree p=T;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>||top&gt;<span class="number">0</span>)&#123;<span class="comment">//栈不空或p不空时循环</span></span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;<span class="comment">//一直往左走</span></span><br><span class="line">            Stack[++top]=p;<span class="comment">//当前结点入栈</span></span><br><span class="line">            p=p-&gt;lchild;<span class="comment">//左孩子不为空一直往左走</span></span><br><span class="line">        &#125;</span><br><span class="line">        p=Stack[top--];<span class="comment">//栈顶元素出栈 并访问</span></span><br><span class="line">        <span class="built_in">visit</span>(p);</span><br><span class="line">        p=p-&gt;rchild;<span class="comment">////向右子树走即p赋值为当前结点的右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后续遍历LRN 逆序 NRL 先根遍历NLR </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder2</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    BiTree Stack1[MAX_SIZE];</span><br><span class="line">    BiTree Stack2[MAX_SIZE];</span><br><span class="line">    <span class="keyword">int</span> top1=<span class="number">0</span>,top2=<span class="number">0</span>;</span><br><span class="line">    BiTree p=T;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>||top1&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            Stack[++top1]=p;</span><br><span class="line">            Stack[++top2]=p;<span class="comment">//存储后序列</span></span><br><span class="line">            p=p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        p=Stack1[top--];</span><br><span class="line">        p=p-&gt;lchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Stack2中的元素依次出栈就是后续遍历。</span></span><br><span class="line">    <span class="keyword">while</span>(top2&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">visit</span>(Stack2[top2]);</span><br><span class="line">        top2--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder2</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    BiTree Stack[MAX_SIZE];</span><br><span class="line">    BiTree p = T, r = <span class="literal">NULL</span>;<span class="comment">// 遍历指针 最近访问过指针</span></span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p !=<span class="literal">NULL</span> || top &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123; <span class="comment">//一直向左走</span></span><br><span class="line">            Stack[++top] = p;</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125;<span class="comment">//向右走</span></span><br><span class="line">        p = Stack[top]; <span class="comment">//获取栈顶元素</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;rchild &amp;&amp; p-&gt;rchild != r) &#123;<span class="comment">//若右子树存在且未被访问过</span></span><br><span class="line">            p = p-&gt;rchild; <span class="comment">//转向右子树</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//否则，弹出结点并访问</span></span><br><span class="line">                p = Stack[top--];</span><br><span class="line">                <span class="built_in">visit</span>(p);<span class="comment">//访问结点</span></span><br><span class="line">                r = p; <span class="comment">//记录最近访问过的结点</span></span><br><span class="line">                p = <span class="literal">NULL</span>;<span class="comment">//结点访问完，重置p指针</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意：每次出栈访问完一个结点就相当于遍历完以该结点为根的子树，需将p置NULL</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(BiTree L)</span></span>&#123;</span><br><span class="line">    BiTree que[MAX_SIZE];</span><br><span class="line">    BiTree q=T;         <span class="comment">//工作指针</span></span><br><span class="line">    <span class="keyword">int</span> front=<span class="number">0</span>,rear=<span class="number">0</span>;<span class="comment">//队列的指针</span></span><br><span class="line">    <span class="keyword">if</span>(q==<span class="literal">NULL</span>) <span class="keyword">return</span>;<span class="comment">//特判</span></span><br><span class="line">    que[++rear]=q;      <span class="comment">//根节点入队</span></span><br><span class="line">    <span class="keyword">while</span>(front&lt;rear)&#123;<span class="comment">//队列不空 则循环</span></span><br><span class="line">        q=que[++front];      <span class="comment">//队头出队</span></span><br><span class="line">        <span class="built_in">visit</span>(q);           <span class="comment">//访问出队结点</span></span><br><span class="line">        <span class="keyword">if</span>(q-&gt;lchild!=<span class="literal">NULL</span>) que[++rear]=q-&gt;lchild;<span class="comment">//左子树不空，入队</span></span><br><span class="line">        <span class="keyword">if</span>(q-&gt;rchild!=<span class="literal">NULL</span>) que[++rear]=q-&gt;rchild;<span class="comment">//右子树不空，入队</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">    ElemType data;                  <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreadNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span><span class="comment">//左，右孩子指针</span></span><br><span class="line">    <span class="keyword">int</span> ltag,rtag;<span class="comment">//左,右线索标志</span></span><br><span class="line">&#125;ThreadNode,*ThreadTree;</span><br><span class="line"><span class="comment">//线索二叉树中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThread</span><span class="params">(ThreadTree &amp;p,ThreadTree &amp;pre)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">InThread</span>(p-&gt;lchild,pre);<span class="comment">//递归线索二叉树</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild=<span class="literal">NULL</span>)&#123;     <span class="comment">//左子树为空建立前驱线索</span></span><br><span class="line">            p-&gt;lchild=pre; </span><br><span class="line">            p-&gt;ltag=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pre!=<span class="literal">NULL</span>&amp;&amp;pre-&gt;rchild==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            pre-&gt;rchild=p;      <span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">            pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre=p;                  <span class="comment">//标记当前结点为刚刚访问过的结点</span></span><br><span class="line">        <span class="built_in">InThread</span>(p-&gt;rchild,pre);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateInThread</span><span class="params">(ThreadTree T)</span></span>&#123;</span><br><span class="line">    ThreadTree pre=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;<span class="comment">//非空二叉树线索化</span></span><br><span class="line">        <span class="built_in">InThread</span>(T,pre);<span class="comment">//线索化二叉树</span></span><br><span class="line">        pre-&gt;rchild=<span class="literal">NULL</span>;<span class="comment">//处理最后一个结点</span></span><br><span class="line">        pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求中序序列下第一个结点</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">Firstnote</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;ltag==<span class="number">0</span>)p=p-&gt;lchild;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求结点p在中序序列下的后继</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">Nextnode</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;rtag==<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">Firstnote</span>(p-&gt;lchild);</span><br><span class="line">    <span class="keyword">return</span> p-&gt;rchild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序线索二叉树的中序遍历算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(ThreadNode *T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ThreadNode *p=<span class="built_in">Firstnode</span>(T);p!=<span class="literal">NULL</span>;p=<span class="built_in">Nextnode</span>(p))&#123;</span><br><span class="line">        <span class="built_in">visit</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_NODE 200</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> weight;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> parent,lchild,rchild;</span><br><span class="line">&#125;HTNode;</span><br><span class="line"><span class="comment">//创建一个叶子结点数为n的Huffman树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Create_Huffman</span><span class="params">(<span class="keyword">unsigned</span> n,HTNode HT[],<span class="keyword">unsigned</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">int</span> k,j;</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">1</span>;k&lt;m;k++)&#123;       <span class="comment">//输入时，所有叶子结点都有权值</span></span><br><span class="line">        <span class="keyword">if</span>(k&lt;=n)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;输入w=&quot;</span>;</span><br><span class="line">            cin&gt;&gt;w;</span><br><span class="line">            HT[k].weight=w;</span><br><span class="line">        &#125;<span class="keyword">else</span> HT[k].weight=<span class="number">0</span>; <span class="comment">//非叶子结点没有权值</span></span><br><span class="line">        HT[k].parent=HT[k].lchild=HT[k].rchild=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(k=n+<span class="number">1</span>;k&lt;m;k++)&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> w1=<span class="number">32767</span>,w2=w1;<span class="comment">//w1,w2分别保存权值最小的两个权值</span></span><br><span class="line">        <span class="keyword">int</span> p1=<span class="number">0</span>,p2=<span class="number">0</span>;          <span class="comment">//p1,p2保存两个最小权值的下标</span></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=k<span class="number">-1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(HT[k].parent==<span class="number">0</span>)&#123;    <span class="comment">//尚未合并</span></span><br><span class="line">                <span class="keyword">if</span>(HT[j].weight&lt;w1)&#123;</span><br><span class="line">                    w2=w1;</span><br><span class="line">                    p2=p1;</span><br><span class="line">                    w1=HT[j].weight;</span><br><span class="line">                    p1=j;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(HT[j].weight&lt;w2)&#123;</span><br><span class="line">                    w2=HT[j].weight;</span><br><span class="line">                    p2=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="comment">//找到权值最小的两个值及其下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        HT[k].lchild=p1;</span><br><span class="line">        HT[k].rchild=p2;</span><br><span class="line">        HT[k].weight=w1+w2;</span><br><span class="line">        HT[p1].parent=k;</span><br><span class="line">        HT[p2].parent=k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Huff_coding</span><span class="params">(<span class="keyword">unsigned</span> n,HTNode HT[],<span class="keyword">unsigned</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k,sp,fp;</span><br><span class="line">    <span class="keyword">char</span> *cd,*HC[m];</span><br><span class="line">    cd=(<span class="keyword">char</span> *)<span class="built_in">malloc</span>(m* <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>));</span><br><span class="line">    cd[n]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">1</span>;k&lt;n+<span class="number">1</span>;k++)&#123;</span><br><span class="line">        sp=n;</span><br><span class="line">        <span class="keyword">int</span> p=k;</span><br><span class="line">        fp=HT[k].parent;</span><br><span class="line">        <span class="keyword">for</span>(;fp!=<span class="number">0</span>;p=fp,fp=HP[p].parent);<span class="comment">//从叶子结点到根你想求编码</span></span><br><span class="line">            <span class="keyword">if</span>(HT[fp].lchild==p)cd[--p]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> cd[--sp]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">            HC[k]=(<span class="keyword">char</span> *)<span class="built_in">malloc</span>((n-sp)*<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>));<span class="comment">//为第k个字符分配保存编码的空间</span></span><br><span class="line">            <span class="built_in">strcpy</span>(HC[k],&amp;cd[sp]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(cd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h2><p>//给定权值集合={3,5,7,9,11,12},请构造关于w的一棵Huffman树，并求其加权路径长度WPL<br>/*</p><ol><li>集合中找到根节点权值最小的两棵树</li><li>合并两棵树生成一棵新的树加入到集合中，删除原来的树</li><li>重复1,2步骤知道只剩下最后一棵树</li></ol><p>3,5,7,9,11,12<br>7,8,9,11,12<br>9,11,12,15<br>12,15,20<br>20,27<br>47<br>*/</p><h3 id="求二叉树所有的叶子结点数"><a href="#求二叉树所有的叶子结点数" class="headerlink" title="求二叉树所有的叶子结点数"></a>求二叉树所有的叶子结点数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(BTNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild==<span class="literal">NULL</span>&amp;&amp;p-&gt;rchild==<span class="literal">NULL</span>)</span><br><span class="line">            ans++;</span><br><span class="line">        <span class="built_in">count</span>(p-&gt;lchild);</span><br><span class="line">        <span class="built_in">count</span>(p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求二叉树中值为x的结点层号"><a href="#求二叉树中值为x的结点层号" class="headerlink" title="求二叉树中值为x的结点层号"></a>求二叉树中值为x的结点层号</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">leno</span><span class="params">(BTNode *p,<span class="keyword">char</span> x,<span class="keyword">int</span> lev)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data==x)</span><br><span class="line">            cout&lt;&lt;lev&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">leno</span>(p-&gt;lchild,x,lev+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">leno</span>(p-&gt;rchild,x,lev+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">leno</span><span class="params">(BTNode *p,<span class="keyword">char</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data==x)</span><br><span class="line">            cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">        ++ans;</span><br><span class="line">        <span class="built_in">leno</span>(p-&gt;lchild,x);</span><br><span class="line">        <span class="built_in">leno</span>(p-&gt;rchild,x);</span><br><span class="line">        --ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="树顺序存储求i和j结点的最近公共祖先结点的值"><a href="#树顺序存储求i和j结点的最近公共祖先结点的值" class="headerlink" title="树顺序存储求i和j结点的最近公共祖先结点的值"></a>树顺序存储求i和j结点的最近公共祖先结点的值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">forefather</span><span class="params">(ptree &amp;p,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>||j&lt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(;i!=<span class="number">0</span>;i/=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(;j!=<span class="number">0</span>;j/=<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==j)&#123;</span><br><span class="line">                    <span class="keyword">return</span> p.HI[i].data;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="满二叉树已知先序pre，求后序post"><a href="#满二叉树已知先序pre，求后序post" class="headerlink" title="满二叉树已知先序pre，求后序post"></a>满二叉树已知先序pre，求后序post</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">char</span> pre[],<span class="keyword">int</span> L1,<span class="keyword">int</span> R1,<span class="keyword">char</span> post[],<span class="keyword">int</span> L2,<span class="keyword">int</span> R2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L1&lt;=R1)&#123;</span><br><span class="line">        post[R2]=pre[L1];<span class="comment">//将pre[]中的第一个元素放在post[]的末尾</span></span><br><span class="line">        <span class="built_in">change</span>(pre,L1+<span class="number">1</span>,(L1+<span class="number">1</span>+R1)/<span class="number">2</span>,post,L2,(L2+R2<span class="number">-1</span>)/<span class="number">2</span>);<span class="comment">//递归处理pre[]中的前一半序列，将其存在post[]数组对应的前一半位置</span></span><br><span class="line">        <span class="built_in">change</span>(pre,(L1+<span class="number">1</span>+R1)/<span class="number">2</span>+<span class="number">1</span>,R1,post,(L2+R2<span class="number">-1</span>)/<span class="number">2</span>+<span class="number">1</span>,R2<span class="number">-1</span>);<span class="comment">//递归处理pre[]中的后一半序列，将其存在post[]数组对应的后一半位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第四章树和二叉树&quot;&gt;&lt;a href=&quot;#第四章树和二叉树&quot; class=&quot;headerlink&quot; title=&quot;第四章树和二叉树&quot;&gt;&lt;/a&gt;第四章树和二叉树&lt;/h2&gt;&lt;h3 id=&quot;二叉树的存储结构&quot;&gt;&lt;a href=&quot;#二叉树的存储结构&quot; class=&quot;head</summary>
      
    
    
    
    
    <category term="考研" scheme="https://insistgang.github.io/tags/%E8%80%83%E7%A0%94/"/>
    
    <category term="datastruct" scheme="https://insistgang.github.io/tags/datastruct/"/>
    
  </entry>
  
</feed>
